#define UNLOADED_FILE
#include <idc.idc>
    
static main(void)
{
MakeComm(0X0071 " MAPL_T1 ");
MakeComm(0X0072 " MAPR_T1 ");
MakeComm(0X0076 " TPS_T1 ");
MakeComm(0X0086 "seems to be RPM");
MakeComm(0X0090 "counter loaded from E065");
MakeComm(0X00B3 "scaled RPM for table LU");
MakeComm(0XE00E " MAP related");
MakeComm(0XE012 " baro multiplier = 54h = 84 ");
MakeComm(0XE01B " TPS ");
MakeComm(0XE0E0 " TPS thresholds for table at E1C0 ");
MakeComm(0XE1A0 " maybe dTPS");
MakeComm(0XE1B0 " related to byte_86");
MakeComm(0XE1C0 "dTPS");
MakeComm(0XE89E "inc byte_84");
MakeComm(0XE931 "byte_84 = 7");
MakeComm(0XEA06 " memory copy?? ");
MakeComm(0XEA8B " D = 86:87 ");
MakeComm(0XEA8D " =200h ");
MakeComm(0XEA90 " bra if 86:87 >200h ");
MakeComm(0XEA94 " TPS - F1h ");
MakeComm(0XEA97 "bra if TPS>F1h) ");
MakeComm(0XEA99 " else clear B ");
MakeComm(0XEA9C " TPS - byte_79 ");
MakeComm(0XEA9E " bra if TPS < byte_79 ");
MakeComm(0XEAA0 " else point to a 4-byte table ");
MakeComm(0XEAA3 " TPS - 3 ");
MakeComm(0XEAA6 " bra if TPS<3 ");
MakeComm(0XEAA8 " else X = E1C1 ");
MakeComm(0XEAA9 " TPS - 5 ");
MakeComm(0XEAAC " bra if TPS<5");
MakeComm(0XEAAE " X = E1C2 ");
MakeComm(0XEAAF "TPS - Ah ");
MakeComm(0XEAB2 " bra if TPS < A ");
MakeComm(0XEAB4 " else X = E1C3 ");
MakeComm(0XEB19 " MAP lookup from 3d LUT at E200");
MakeComm(0XEB1B " otherwise a TPS look up");
MakeComm(0XEB42 "MAPL_T1 look up");
MakeComm(0XEB4C "MAPR_T1 lookup");
MakeComm(0XEB58 "use MAPR if MAPL fault*");
MakeComm(0XEB5A "get value from table look up");
MakeComm(0XEB5C "and save to byte_56");
MakeComm(0XEB5F " get MAPR_Raw ");
MakeComm(0XEB63 " copy 56 to 58 ");
MakeComm(0XEB78 "if 0? get value from E500");
MakeComm(0XEB7A "else load default = 50h = 80 ");
MakeComm(0XEBB2 "TPS v RPM");
MakeComm(0XEBDD " bra if MAPR fault ");
MakeComm(0XEBDF " else get MAPL ");
MakeComm(0XEBE3 " fetch MAPL, MAPR ");
MakeComm(0XEBE6 " MAP average = (L+R)/2");
MakeComm(0XEC00 " always call this");
MakeComm(0XEC3E "byte_84 = 16");
MakeComm(0XEC6E " turn on LED3 and LED2 ");
MakeComm(0XED1C "clear P12");
MakeComm(0XED2E "OCR1H - FRCH");
MakeComm(0XED30 "has the time passed?");
MakeComm(0XED34 "OCR1H - 336us ");
MakeComm(0XED37 "OCR1H-336us - FRCH");
MakeComm(0XED43 "clear ICF");
MakeComm(0XED48 "set IC En");
MakeComm(0XED51 " 20us timer ");
MakeComm(0XED83 "clear P13");
MakeComm(0XEDB1 " 5.12ms");
MakeComm(0XEE93 "=10h");
MakeComm(0XEEFE "LEDs on, ?? ");
MakeComm(0XEF09 "clear PORT2 all ");
MakeComm(0XEF0E "set EICI, EOCI, IEDG, OLVL");
MakeComm(0XEF10 "set EICI, EOCI, IEDG, OLVL");
MakeComm(0XEF12 "=30us?");
MakeComm(0XEF17 " set up a pulse 30us long ");
MakeComm(0XEF19 " set up a pulse 30us long ");
MakeComm(0XEF47 "count_91=2Fh");
MakeComm(0XEF49 " byte_84=10h=16 ");
MakeComm(0XEF72 "toggle the watchdog");
MakeComm(0XEF8B "A:B = TPS:TPS");
MakeComm(0XEF8E "TPS_T1:byte_77");
MakeComm(0XEF90 "byte_78:byte_79");
MakeComm(0XEFA6 "clear flags?");
MakeComm(0XEFB2 "toggle P23 - IRQ?");
MakeComm(0XEFB6 "toggle P23 - IRQ?");
MakeComm(0XEFDC "code");
MakeComm(0XF049 "byte_84=10h=16");
MakeComm(0XF04D "clear byte_86");
MakeComm(0XF06F "turn on LED3 and LED2");
MakeComm(0XF073 "clear word_86");
MakeComm(0XF075 "clear byte_AD");
MakeComm(0XF07C "toggle the watchdog");
MakeComm(0XF2C4 "A4:A5");
MakeComm(0XF2CD "PORT1:PORT2");
MakeComm(0XF2CF "LEDs OFF");
MakeComm(0XF2D1 "set P22");
MakeComm(0XF2D3 "update PORT1:PORT2");
MakeComm(0XF2D7 "test byte_A5");
MakeComm(0XF2FD " count_8F << 4 ");
MakeComm(0XF301 " LEDs off");
MakeComm(0XF303 " add LED bits");
MakeComm(0XF306 " clear P22 ");
MakeComm(0XF308 " save PORT1:PORT2 ");
MakeComm(0XF33C "LEDs off");
MakeComm(0XF3C8 " D = TPS:TPS");
MakeComm(0XF3CE " B=B-byte_79");
MakeComm(0XF3D0 "bra if TPS>byte_79");
MakeComm(0XF3EB " A TPS delta?");
MakeComm(0XF3FB " also loc_EA8B");
MakeComm(0XF3FD "=200h");
MakeComm(0XF404 "=F1");
MakeComm(0XF49D " table is all 0's ");
MakeComm(0XF4A3 "always 0");
MakeComm(0XF4E7 "=200h");
MakeComm(0XF4F2 "=3h");
MakeComm(0XF4F7 "=0h");
MakeComm(0XF60B " default value to AF? ");
MakeComm(0XF614 "16-bit offset");
MakeComm(0XF627 "return a value in B");
MakeComm(0XF6DF "inc byte_84");
MakeComm(0XF70A "toggle P23 - nIRQ?");
MakeComm(0XF70E "toggle P23 - nIRQ?");
MakeComm(0XF73C "byte_84 = Fh");
MakeComm(0XF747 "test IC1 IF ");
MakeComm(0XF749 "bra if zero?");
MakeComm(0XF773 "byte_84 = 7");
MakeComm(0XF893 "byte_84=10h=16");
MakeComm(0XF8F2 "JMP_TBL3");
MakeComm(0XF8FA "adcb is one byte!!!!");
MakeComm(0XF8FF " this is in the stack??? ");
MakeComm(0XF9F5 "toggle watchdog");
MakeComm(0XFA56 "code?");
MakeComm(0XFA8A " set up a 5.12ms interrupt ");
MakeComm(0XFAB8 " 20us timer");
MakeComm(0XFB4E "test PORT1?");
MakeComm(0XFB57 "test PORT1?");
MakeComm(0XFCCD "byte_48 or byte_4A");
MakeComm(0XFCDC "12us timer");
MakeComm(0XFCEA "=FRCH, 65.5ms timer?");
MakeComm(0XFCFF " byte_43");
MakeComm(0XFD0F " byte_40 ???");
MakeComm(0XFDAE "PORT1?");
MakeComm(0XFE7A " table_LU ");
MakeComm(0XFE99 " 2D table LU ");
MakeComm(0XFE9D " memory error - this should be 10h = a row/column ");
MakeComm(0XFEC2 " A*16 = row/column");
MakeComm(0XFF2E " divide by 128 ");
MakeComm(0XFFC6 " this appears to copy one memory section to another ");
MakeComm(0XFFD0 " stack = 4 ");
MakeComm(0XFFD4 " loop until x=0 ");
MakeComm(0XFFD4 " stack = C008 ");
MakeComm(0XFFD5 " D = (C008) ");
MakeComm(0XFFD8 " stack = (C008) ");
MakeComm(0XFFD9 " X = (C008) ");
MakeComm(0XFFDA " D = 0,(C008) ");
MakeComm(0XFFDC " X = C008 ");
MakeComm(0XFFDD " C00A = D ");
MakeComm(0XFFDF " stack = C008 ");
MakeComm(0XFFE1 "  D = C008 ");
MakeComm(0XFFE2 " X = loop count? ");
}
