#define UNLOADED_FILE
#include <idc.idc>
    
static main(void)
{
set_cmt(0071 " MAPL_T1 "  1);
set_cmt(0072 " MAPR_T1 "  1);
set_cmt(0076 " TPS_T1 "  1);
set_cmt(0086 "seems to be RPM"  1);
set_cmt(0090 "counter loaded from E065"  1);
set_cmt(00B3 "scaled RPM for table LU"  1);
set_cmt(E00E " MAP related"  1);
set_cmt(E012 " baro multiplier = 54h = 84 "  1);
set_cmt(E01B " TPS "  1);
set_cmt(E0E0 " TPS thresholds for table at E1C0 "  1);
set_cmt(E1A0 " maybe dTPS"  1);
set_cmt(E1B0 " related to byte_86"  1);
set_cmt(E1C0 "dTPS"  1);
set_cmt(E89E "inc byte_84"  1);
set_cmt(E931 "byte_84 = 7"  1);
set_cmt(EA06 " memory copy?? "  1);
set_cmt(EA8B " D = 86:87 "  1);
set_cmt(EA8D " =200h "  1);
set_cmt(EA90 " bra if 86:87 >200h "  1);
set_cmt(EA94 " TPS - F1h "  1);
set_cmt(EA97 "bra if TPS>F1h) "  1);
set_cmt(EA99 " else clear B "  1);
set_cmt(EA9C " TPS - byte_79 "  1);
set_cmt(EA9E " bra if TPS < byte_79 "  1);
set_cmt(EAA0 " else point to a 4-byte table "  1);
set_cmt(EAA3 " TPS - 3 "  1);
set_cmt(EAA6 " bra if TPS<3 "  1);
set_cmt(EAA8 " else X = E1C1 "  1);
set_cmt(EAA9 " TPS - 5 "  1);
set_cmt(EAAC " bra if TPS<5"  1);
set_cmt(EAAE " X = E1C2 "  1);
set_cmt(EAAF "TPS - Ah "  1);
set_cmt(EAB2 " bra if TPS < A "  1);
set_cmt(EAB4 " else X = E1C3 "  1);
set_cmt(EB19 " MAP lookup from 3d LUT at E200"  1);
set_cmt(EB1B " otherwise a TPS look up"  1);
set_cmt(EB42 "MAPL_T1 look up"  1);
set_cmt(EB4C "MAPR_T1 lookup"  1);
set_cmt(EB58 "use MAPR if MAPL fault*"  1);
set_cmt(EB5A "get value from table look up"  1);
set_cmt(EB5C "and save to byte_56"  1);
set_cmt(EB5F " get MAPR_Raw "  1);
set_cmt(EB63 " copy 56 to 58 "  1);
set_cmt(EB78 "if 0? get value from E500"  1);
set_cmt(EB7A "else load default = 50h = 80 "  1);
set_cmt(EBB2 "TPS v RPM"  1);
set_cmt(EBDD " bra if MAPR fault "  1);
set_cmt(EBDF " else get MAPL "  1);
set_cmt(EBE3 " fetch MAPL, MAPR "  1);
set_cmt(EBE6 " MAP average = (L+R)/2"  1);
set_cmt(EC00 " always call this"  1);
set_cmt(EC3E "byte_84 = 16"  1);
set_cmt(EC6E " turn on LED3 and LED2 "  1);
set_cmt(ED1C "clear P12"  1);
set_cmt(ED2E "OCR1H - FRCH"  1);
set_cmt(ED30 "has the time passed?"  1);
set_cmt(ED34 "OCR1H - 336us "  1);
set_cmt(ED37 "OCR1H-336us - FRCH"  1);
set_cmt(ED43 "clear ICF"  1);
set_cmt(ED48 "set IC En"  1);
set_cmt(ED51 " 20us timer "  1);
set_cmt(ED83 "clear P13"  1);
set_cmt(EDB1 " 5.12ms"  1);
set_cmt(EE93 "=10h"  1);
set_cmt(EEFE "LEDs on, ?? "  1);
set_cmt(EF09 "clear PORT2 all "  1);
set_cmt(EF0E "set EICI, EOCI, IEDG, OLVL"  1);
set_cmt(EF10 "set EICI, EOCI, IEDG, OLVL"  1);
set_cmt(EF12 "=30us?"  1);
set_cmt(EF17 " set up a pulse 30us long "  1);
set_cmt(EF19 " set up a pulse 30us long "  1);
set_cmt(EF47 "count_91=2Fh"  1);
set_cmt(EF49 " byte_84=10h=16 "  1);
set_cmt(EF72 "toggle the watchdog"  1);
set_cmt(EF8B "A:B = TPS:TPS"  1);
set_cmt(EF8E "TPS_T1:byte_77"  1);
set_cmt(EF90 "byte_78:byte_79"  1);
set_cmt(EFA6 "clear flags?"  1);
set_cmt(EFB2 "toggle P23 - IRQ?"  1);
set_cmt(EFB6 "toggle P23 - IRQ?"  1);
set_cmt(EFDC "code"  1);
set_cmt(F049 "byte_84=10h=16"  1);
set_cmt(F04D "clear byte_86"  1);
set_cmt(F06F "turn on LED3 and LED2"  1);
set_cmt(F073 "clear word_86"  1);
set_cmt(F075 "clear byte_AD"  1);
set_cmt(F07C "toggle the watchdog"  1);
set_cmt(F2C4 "A4:A5"  1);
set_cmt(F2CD "PORT1:PORT2"  1);
set_cmt(F2CF "LEDs OFF"  1);
set_cmt(F2D1 "set P22"  1);
set_cmt(F2D3 "update PORT1:PORT2"  1);
set_cmt(F2D7 "test byte_A5"  1);
set_cmt(F2FD " count_8F << 4 "  1);
set_cmt(F301 " LEDs off"  1);
set_cmt(F303 " add LED bits"  1);
set_cmt(F306 " clear P22 "  1);
set_cmt(F308 " save PORT1:PORT2 "  1);
set_cmt(F33C "LEDs off"  1);
set_cmt(F3C8 " D = TPS:TPS"  1);
set_cmt(F3CE " B=B-byte_79"  1);
set_cmt(F3D0 "bra if TPS>byte_79"  1);
set_cmt(F3EB " A TPS delta?"  1);
set_cmt(F3FB " also loc_EA8B"  1);
set_cmt(F3FD "=200h"  1);
set_cmt(F404 "=F1"  1);
set_cmt(F49D " table is all 0's "  1);
set_cmt(F4A3 "always 0"  1);
set_cmt(F4E7 "=200h"  1);
set_cmt(F4F2 "=3h"  1);
set_cmt(F4F7 "=0h"  1);
set_cmt(F60B " default value to AF? "  1);
set_cmt(F614 "16-bit offset"  1);
set_cmt(F627 "return a value in B"  1);
set_cmt(F6DF "inc byte_84"  1);
set_cmt(F70A "toggle P23 - nIRQ?"  1);
set_cmt(F70E "toggle P23 - nIRQ?"  1);
set_cmt(F73C "byte_84 = Fh"  1);
set_cmt(F747 "test IC1 IF "  1);
set_cmt(F749 "bra if zero?"  1);
set_cmt(F773 "byte_84 = 7"  1);
set_cmt(F893 "byte_84=10h=16"  1);
set_cmt(F8F2 "JMP_TBL3"  1);
set_cmt(F8FA "adcb is one byte!!!!"  1);
set_cmt(F8FF " this is in the stack??? "  1);
set_cmt(F9F5 "toggle watchdog"  1);
set_cmt(FA56 "code?"  1);
set_cmt(FA8A " set up a 5.12ms interrupt "  1);
set_cmt(FAB8 " 20us timer"  1);
set_cmt(FB4E "test PORT1?"  1);
set_cmt(FB57 "test PORT1?"  1);
set_cmt(FCCD "byte_48 or byte_4A"  1);
set_cmt(FCDC "12us timer"  1);
set_cmt(FCEA "=FRCH, 65.5ms timer?"  1);
set_cmt(FCFF " byte_43"  1);
set_cmt(FD0F " byte_40 ???"  1);
set_cmt(FDAE "PORT1?"  1);
set_cmt(FE7A " table_LU "  1);
set_cmt(FE99 " 2D table LU "  1);
set_cmt(FE9D " memory error - this should be 10h = a row/column "  1);
set_cmt(FEC2 " A*16 = row/column"  1);
set_cmt(FF2E " divide by 128 "  1);
set_cmt(FFC6 " this appears to copy one memory section to another "  1);
set_cmt(FFD0 " stack = 4 "  1);
set_cmt(FFD4 " loop until x=0 "  1);
set_cmt(FFD4 " stack = C008 "  1);
set_cmt(FFD5 " D = (C008) "  1);
set_cmt(FFD8 " stack = (C008) "  1);
set_cmt(FFD9 " X = (C008) "  1);
set_cmt(FFDA " D = 0,(C008) "  1);
set_cmt(FFDC " X = C008 "  1);
set_cmt(FFDD " C00A = D "  1);
set_cmt(FFDF " stack = C008 "  1);
set_cmt(FFE1 "  D = C008 "  1);
set_cmt(FFE2 " X = loop count? "  1);
}
