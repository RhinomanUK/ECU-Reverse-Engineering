//
// +-------------------------------------------------------------------------+
// |   This file has been generated by The Interactive Disassembler (IDA)    |
// |        Copyright (c) 2009 by Hex-Rays, <support@hex-rays.com>           |
// |                      License info: 54-F19A-B286-08                      |
// |                              James Holland                              |
// +-------------------------------------------------------------------------+
//
//
//      This file should be used in the following way:
//         - reload executable into IDA with using switch -c
//         - use File, Load IDC file and load this file.
//
//      NOTE: This file doesn't contain all information from the database.
//

#define UNLOADED_FILE   1
#include <idc.idc>

static main(void)
{
  // set 'loading idc file' mode
  SetCharPrm(INF_GENFLAGS, INFFL_LOADIDC|GetCharPrm(INF_GENFLAGS));
  GenInfo();            // various settings
  Segments();           // segmentation
  Enums();              // enumerations
  Structures();         // structure types
  Patches();            // manual patches
  SegRegs();            // segment register values
  Bytes();              // individual bytes (code,data)
  Functions();          // function definitions
  // clear 'loading idc file' mode
  SetCharPrm(INF_GENFLAGS, ~INFFL_LOADIDC&GetCharPrm(INF_GENFLAGS));
}

//------------------------------------------------------------------------
// General information

static GenInfo(void) {

        DeleteAll();    // purge database
	SetPrcsr("6301");
	StringStp(0xA);
	Tabs(1);
	Comments(0);
	Voids(0);
	XrefShow(2);
	AutoShow(1);
	Indent(16);
	CmtIndent(40);
	TailDepth(0x10);
}

//------------------------------------------------------------------------
// Information about segmentation

static Segments(void) {
	SetSelector(0X1,0X0);
	;
	SegCreate(0X0,0X100,0X0,0,1,2);
	SegRename(0X0,"RAM");
	SegClass (0X0,"");
	SegCreate(0XC000,0XC00F,0X0,0,1,2);
	SegRename(0XC000,"PE");
	SegClass (0XC000,"");
	SegCreate(0XD000,0XD004,0X0,0,1,2);
	SegRename(0XD000,"ADC");
	SegClass (0XD000,"");
	SegCreate(0XE000,0X10000,0X0,0,1,2);
	SegRename(0XE000,"ROM");
	SegClass (0XE000,"CODE");
	SetSegmentType(0XE000,2);
	LowVoids(0x0);
	HighVoids(0x10000);
}

//------------------------------------------------------------------------
// Information about enum types

static Enums(void) {
        auto id;
}

//------------------------------------------------------------------------
// Information about structure types

static Structures(void) {
        auto id;
}

//------------------------------------------------------------------------
// Information about bytes

static Bytes_0(void) {
        auto x;
#define id x

	MakeComm	(0X0,	"=FEh");
	ExtLinA		(0X0,	0,	"; File Name   : P:\\ECUs_no_sync\\GL1200\\GL1200.bin");
	ExtLinA		(0X0,	1,	"; Format      : Binary file");
	ExtLinA		(0X0,	2,	"; Base Address: 0000h Range: E000h - 10000h Loaded length: 2000h");
	ExtLinA		(0X0,	3,	";");
	ExtLinA		(0X0,	4,	"; 1985 Honda GL1200 ECU");
	ExtLinA		(0X0,	5,	"; This ECU appears to use a Toshiba processor based on the 63xx architecture");
	ExtLinA		(0X0,	6,	"; instructions to be investigated:");
	ExtLinA		(0X0,	7,	";          adcb, ind,x");
	ExtLinA		(0X0,	8,	";          03 = oim?");
	ExtLinA		(0X0,	9,	";          cpx - some of these aren't tested");
	ExtLinA		(0X0,	10,	";          some misaligned branches ");
	ExtLinA		(0X0,	11,	";          check stack operation onn calls    ");
	ExtLinA		(0X0,	12,	"; A second 40-pin chip contains an ADC and some other ");
	ExtLinA		(0X0,	13,	"; (TBD - timer and port expander?) functions ");
	ExtLinA		(0X0,	14,	"; There are a total of 5202 bytes of code      ");
	ExtLinA		(0X0,	15,	"; Date: 20th December 2023");
	MakeByte	(0X0);
	MakeName	(0X0,	"P1DDR");
	MakeComm	(0X1,	"=1Eh");
	MakeName	(0X1,	"P2DDR");
	ExtLinA		(0X2,	0,	";");
	ExtLinA		(0X2,	1,	"; Port 1 Data register  ");
	ExtLinA		(0X2,	2,	"; bit 7 (0x80): out - LED3 (external drivers invert!)                                         ");
	ExtLinA		(0X2,	3,	"; bit 6 (0x40): out - LED2");
	ExtLinA		(0X2,	4,	"; bit 5 (0x20): out - LED1");
	ExtLinA		(0X2,	5,	"; bit 4 (0x10): out - LED0");
	ExtLinA		(0X2,	6,	"; bit 3 (0x08): out - INJL");
	ExtLinA		(0X2,	7,	"; bit 2 (0x04): out - INJR");
	ExtLinA		(0X2,	8,	"; bit 1 (0x02): out - OC2/IGN12");
	ExtLinA		(0X2,	9,	"; bit 0 (0x01): in  - Right Cam Sensor");
	MakeByte	(0X2);
	MakeName	(0X2,	"PORT1");
	ExtLinA		(0X3,	0,	";");
	ExtLinA		(0X3,	1,	"; Port 2 Data register  ");
	ExtLinA		(0X3,	2,	"; bit 7 (0x80): in - no external connection");
	ExtLinA		(0X3,	3,	"; bit 6 (0x40): in - no external connection ");
	ExtLinA		(0X3,	4,	"; bit 5 (0x20): in - no external connection ");
	ExtLinA		(0X3,	5,	"; bit 4 (0x10): out - Watchdog Reset");
	ExtLinA		(0X3,	6,	"; bit 3 (0x08): out - IRQ IF Clear");
	ExtLinA		(0X3,	7,	"; bit 2 (0x04): out - LEDW");
	ExtLinA		(0X3,	8,	"; bit 1 (0x02): out - OC1/IGN34");
	ExtLinA		(0X3,	9,	"; bit 0 (0x01): in  - Crank Sensor (Ns)");
	MakeByte	(0X3);
	MakeName	(0X3,	"PORT2");
	MakeByte	(0X4);
	MakeName	(0X4,	"P3DDR");
	MakeByte	(0X5);
	MakeName	(0X5,	"P4DDR");
	MakeByte	(0X6);
	MakeName	(0X6,	"PORT3");
	MakeByte	(0X7);
	MakeName	(0X7,	"PORT4");
	ExtLinA		(0X8,	0,	";");
	ExtLinA		(0X8,	1,	"; Timer Control & Status Register 1");
	ExtLinA		(0X8,	2,	"; bit 7 (0x80): ICF1");
	ExtLinA		(0X8,	3,	"; bit 6 (0x40): OCF1");
	ExtLinA		(0X8,	4,	"; bit 5 (0x20): TOF1");
	ExtLinA		(0X8,	5,	"; bit 4 (0x10): EICI1      ");
	ExtLinA		(0X8,	6,	"; bit 3 (0x08): EOCI1");
	ExtLinA		(0X8,	7,	"; bit 2 (0x04): ETOI1         ");
	ExtLinA		(0X8,	8,	"; bit 1 (0x02): IEDG1    ");
	ExtLinA		(0X8,	9,	"; bit 0 (0x01): OLVL1");
	MakeByte	(0X8);
	MakeName	(0X8,	"TCSR1");
	MakeByte	(0X9);
	MakeName	(0X9,	"FRCH");
	MakeByte	(0XA);
	MakeName	(0XA,	"FRCL");
	MakeComm	(0XB,	"IGN34 output compare");
	MakeByte	(0XB);
	MakeName	(0XB,	"OCR1H");
	MakeByte	(0XC);
	MakeName	(0XC,	"OCR1L");
	MakeByte	(0XD);
	MakeName	(0XD,	"ICR1H");
	MakeByte	(0XE);
	MakeName	(0XE,	"ICR1L");
	MakeByte	(0XF);
	MakeName	(0XF,	"P3CSR");
	MakeByte	(0X10);
	MakeName	(0X10,	"RMCR");
	MakeByte	(0X11);
	MakeName	(0X11,	"TRCSR1");
	MakeByte	(0X12);
	MakeName	(0X12,	"RDR");
	MakeByte	(0X13);
	MakeName	(0X13,	"TDR");
	MakeByte	(0X14);
	MakeName	(0X14,	"RAMCR");
	MakeByte	(0X15);
	MakeByte	(0X16);
	MakeByte	(0X17);
	ExtLinA		(0X18,	0,	";");
	ExtLinA		(0X18,	1,	"; Timer Control & Status Register 2");
	ExtLinA		(0X18,	2,	"; bit 7 (0x80): ICF2");
	ExtLinA		(0X18,	3,	"; bit 6 (0x40): OCF2");
	ExtLinA		(0X18,	4,	"; bit 5 (0x20): TOF2");
	ExtLinA		(0X18,	5,	"; bit 4 (0x10): EICI2      ");
	ExtLinA		(0X18,	6,	"; bit 3 (0x08): EOCI2");
	ExtLinA		(0X18,	7,	"; bit 2 (0x04): ETOI2         ");
	ExtLinA		(0X18,	8,	"; bit 1 (0x02): IEDG2    ");
	ExtLinA		(0X18,	9,	"; bit 0 (0x01): OLVL2");
	MakeByte	(0X18);
	MakeName	(0X18,	"TCSR2");
	MakeByte	(0X19);
	MakeByte	(0X1A);
	MakeComm	(0X1B,	"IGN12 output compare");
	MakeByte	(0X1B);
	MakeName	(0X1B,	"OCR2H");
	MakeByte	(0X1C);
	MakeByte	(0X1D);
	MakeName	(0X1D,	"ICR2H");
	MakeByte	(0X1E);
	MakeByte	(0X1F);
	MakeByte	(0X20);
	MakeByte	(0X21);
	MakeByte	(0X40);
	MakeByte	(0X42);
	MakeByte	(0X44);
	MakeByte	(0X45);
	MakeByte	(0X46);
	MakeByte	(0X48);
	MakeByte	(0X4A);
	MakeByte	(0X4C);
	MakeByte	(0X4D);
	MakeByte	(0X4E);
	MakeByte	(0X50);
	MakeRptCmt	(0X51,	"increments every 4ms");
	MakeByte	(0X51);
	MakeName	(0X51,	"count_4ms");
	MakeByte	(0X52);
	MakeByte	(0X54);
	MakeByte	(0X56);
	MakeRptCmt	(0X58,	"MAP related, result from 3d LUT");
	MakeByte	(0X58);
	MakeName	(0X58,	"result_58");
	MakeByte	(0X5A);
	MakeName	(0X5A,	"VBatt_5A");
	MakeByte	(0X5C);
	MakeByte	(0X5E);
	MakeName	(0X5E,	"Baro_IAT_5E");
	MakeByte	(0X5F);
	MakeRptCmt	(0X60,	"a copy of CTS_C0 or CTS_BE");
	MakeByte	(0X60);
	MakeName	(0X60,	"CTS_60");
	MakeByte	(0X61);
	MakeByte	(0X62);
	MakeRptCmt	(0X63,	"from LUT at E500");
	MakeByte	(0X63);
	MakeByte	(0X64);
	MakeName	(0X64,	"CTS_64");
	MakeByte	(0X65);
	MakeByte	(0X66);
	MakeByte	(0X68);
	MakeRptCmt	(0X69,	"from the LUT at E190");
	MakeByte	(0X69);
	MakeName	(0X69,	"VBatt_69");
	MakeByte	(0X6B);
	MakeByte	(0X6D);
	MakeName	(0X6D,	"count_6D");
	MakeByte	(0X6E);
	MakeName	(0X6E,	"CTS");
	MakeByte	(0X6F);
	MakeName	(0X6F,	"IAT");
	MakeByte	(0X70);
	MakeName	(0X70,	"Baro_70");
	MakeComm	(0X71,	" MAPL_T1 ");
	MakeRptCmt	(0X71,	"MAPL_Tn =");
	MakeByte	(0X71);
	MakeName	(0X71,	"MAPL_Tn");
	MakeComm	(0X72,	" MAPR_T1 ");
	MakeByte	(0X72);
	MakeName	(0X72,	"MAPR_T1");
	MakeByte	(0X73);
	MakeName	(0X73,	"MAPL");
	MakeByte	(0X74);
	MakeName	(0X74,	"MAPR");
	ExtLinA		(0X75,	0,	"TPS Buffer:");
	MakeByte	(0X75);
	MakeName	(0X75,	"TPS");
	MakeComm	(0X76,	" TPS_T1 ");
	MakeByte	(0X76);
	MakeName	(0X76,	"TPS_4ms");
	MakeByte	(0X77);
	MakeName	(0X77,	"TPS_8ms");
	MakeByte	(0X78);
	MakeName	(0X78,	"TPS_12ms");
	MakeByte	(0X79);
	MakeName	(0X79,	"TPS_16ms");
	MakeByte	(0X7A);
	MakeRptCmt	(0X7B,	"VBatt = B+ * 0.2857");
	MakeByte	(0X7B);
	MakeName	(0X7B,	"VBatt");
	MakeByte	(0X7C);
	MakeName	(0X7C,	"Baro_7C");
	MakeByte	(0X7D);
	MakeName	(0X7D,	"IAT_7D");
	MakeByte	(0X7E);
	MakeName	(0X7E,	"dCAS_Count");
	MakeRptCmt	(0X80,	"= dCAS_Count/2");
	MakeByte	(0X80);
	MakeName	(0X80,	"dCAS_Count_T1");
	MakeByte	(0X82);
	MakeName	(0X82,	"CAS_Count");
	MakeByte	(0X84);
	MakeByte	(0X85);
	MakeName	(0X85,	"count_4ms_B");
	MakeComm	(0X86,	"seems to be RPM");
	MakeByte	(0X86);
	MakeRptCmt	(0X88,	"high byte");
	ExtLinA		(0X88,	0,	"");
	ExtLinA		(0X88,	1,	"dCAS_Av_2 - this is  17bit number");
	ExtLinA		(0X88,	2,	"dCAS_AV_2 = dCAS_AV /2");
	MakeByte	(0X88);
	MakeName	(0X88,	"dCAS_Av_2H");
	MakeRptCmt	(0X89,	"middle byte");
	MakeByte	(0X89);
	MakeName	(0X89,	"dCAS_Av_2M");
	MakeRptCmt	(0X8A,	"low byte");
	MakeByte	(0X8A);
	MakeName	(0X8A,	"dCAS_Av_2L");
	ExtLinA		(0X8B,	0,	"");
	ExtLinA		(0X8B,	1,	"dCAS_AV - this is a 17-bit number");
	ExtLinA		(0X8B,	2,	"dCAS_Av = dCAS_Av + (0.5 * lastdCAS_Av)");
	MakeByte	(0X8B);
	MakeName	(0X8B,	"dCAS_AVH");
	MakeRptCmt	(0X8C,	"= (dCAS_Count/2) + dCAS_Av");
	MakeByte	(0X8C);
	MakeName	(0X8C,	"dCAS_Av16");
	MakeRptCmt	(0X8E,	"4.096ms timer");
	MakeByte	(0X8E);
	MakeName	(0X8E,	"tmr_4ms");
	MakeByte	(0X8F);
	MakeName	(0X8F,	"LEDs_8F");
	MakeComm	(0X90,	"counter loaded from E065");
	MakeByte	(0X90);
	MakeByte	(0X91);
	MakeName	(0X91,	"count_91");
	MakeName	(0X92,	"IAT_Raw");
	MakeName	(0X93,	"CTS_Raw");
	MakeName	(0X94,	"BARO_Raw");
	MakeByte	(0X95);
	MakeName	(0X95,	"MAPL_Raw");
	MakeByte	(0X96);
	MakeName	(0X96,	"MAPR_Raw");
	MakeByte	(0X97);
	MakeName	(0X97,	"TPS_Raw");
	MakeByte	(0X98);
	MakeName	(0X98,	"count_98");
	MakeRptCmt	(0X9D,	"16ms tick");
	MakeByte	(0X9D);
	MakeName	(0X9D,	"Count_9D");
	MakeComm	(0X9E,	"appears to be IGN34 status");
	MakeByte	(0X9E);
	MakeName	(0X9E,	"Ign_Status_9E");
	MakeByte	(0X9F);
	ExtLinA		(0XA0,	0,	"; status_A0:");
	ExtLinA		(0XA0,	1,	";  bit 7 (0x80): ");
	ExtLinA		(0XA0,	2,	";  bit 6 (0x40): ");
	ExtLinA		(0XA0,	3,	";  bit 5 (0x20): ");
	ExtLinA		(0XA0,	4,	";  bit 4 (0x10):       ");
	ExtLinA		(0XA0,	5,	";  bit 3 (0x08): ");
	ExtLinA		(0XA0,	6,	";  bit 2 (0x04):          ");
	ExtLinA		(0XA0,	7,	";  bit 1 (0x02):    ");
	ExtLinA		(0XA0,	8,	";  bit 0 (0x01): table switch MAP/TPS");
	MakeByte	(0XA0);
	MakeName	(0XA0,	"status_A0");
	MakeByte	(0XA1);
	MakeName	(0XA1,	"count_A1");
	ExtLinA		(0XA2,	0,	"");
	ExtLinA		(0XA2,	1,	"; status_A2:");
	ExtLinA		(0XA2,	2,	";  bit 7 (0x80): ");
	ExtLinA		(0XA2,	3,	";  bit 6 (0x40): ");
	ExtLinA		(0XA2,	4,	";  bit 5 (0x20):");
	ExtLinA		(0XA2,	5,	";  bit 4 (0x10):       ");
	ExtLinA		(0XA2,	6,	";  bit 3 (0x08): ");
	ExtLinA		(0XA2,	7,	";  bit 2 (0x04):          ");
	ExtLinA		(0XA2,	8,	";  bit 1 (0x02): new dCAS value ");
	ExtLinA		(0XA2,	9,	";  bit 0 (0x01): ");
	MakeByte	(0XA2);
	MakeName	(0XA2,	"status_A2");
	ExtLinA		(0XA3,	0,	"");
	ExtLinA		(0XA3,	1,	"; status_A3:");
	ExtLinA		(0XA3,	2,	";  bit 7 (0x80): ");
	ExtLinA		(0XA3,	3,	";  bit 6 (0x40): ");
	ExtLinA		(0XA3,	4,	";  bit 5 (0x20): Set on Crank sensor interrupt");
	ExtLinA		(0XA3,	5,	";  bit 4 (0x10):       ");
	ExtLinA		(0XA3,	6,	";  bit 3 (0x08): ");
	ExtLinA		(0XA3,	7,	";  bit 2 (0x04):          ");
	ExtLinA		(0XA3,	8,	";  bit 1 (0x02):    ");
	ExtLinA		(0XA3,	9,	";  bit 0 (0x01): ");
	MakeByte	(0XA3);
	MakeName	(0XA3,	"status_A3");
	MakeByte	(0XA4);
	MakeByte	(0XA5);
	MakeByte	(0XA6);
	MakeByte	(0XA7);
	MakeByte	(0XA8);
	MakeRptCmt	(0XA9,	"either 7F or 0, set after read from PIA?");
	MakeByte	(0XA9);
	MakeName	(0XA9,	"config_A9?");
	MakeByte	(0XAA);
	MakeByte	(0XAC);
	MakeByte	(0XAD);
	MakeByte	(0XAE);
	MakeRptCmt	(0XAF,	"temporary register (Heap)?");
	MakeByte	(0XAF);
	MakeByte	(0XB0);
	MakeByte	(0XB1);
	MakeByte	(0XB2);
	MakeComm	(0XB3,	"scaled RPM for table LU");
	MakeByte	(0XB3);
	MakeByte	(0XB5);
	MakeByte	(0XB6);
	MakeByte	(0XB7);
	MakeByte	(0XB9);
	MakeByte	(0XBB);
	MakeByte	(0XBC);
	MakeByte	(0XBE);
	MakeName	(0XBE,	"CTS_BE");
	MakeByte	(0XC0);
	MakeName	(0XC0,	"CTS_C0");
	MakeRptCmt	(0XC2,	"16ms tick");
	MakeByte	(0XC2);
	MakeName	(0XC2,	"count_C2");
	MakeByte	(0XC4);
	MakeName	(0XC4,	"count_C4");
	MakeByte	(0XD2);
	MakeByte	(0XF9);
	MakeComm	(0XC000,	"only read compared to 56h or A9h\nbit7 is ctrl bit\nbit0 is status - action on 1");
	MakeByte	(0XC000);
	MakeRptCmt	(0XC001,	"read/write");
	MakeByte	(0XC001);
	MakeRptCmt	(0XC002,	"read only shift and test (RTC like?)");
	MakeWord	(0XC002);
	MakeRptCmt	(0XC004,	"read only used as a ptr to upper addresses in this chip?");
	MakeByte	(0XC004);
	MakeWord	(0XC006);
	ExtLinA		(0XD000,	0,	"; IC402 is a hitherto undocumented 40-pin DIP IC.");
	ExtLinA		(0XD000,	1,	"; It is a Port Expander/Peripheral Interface Adapter");
	ExtLinA		(0XD000,	2,	"; PIA Ctrl appears to address 1 of two control registers");
	ExtLinA		(0XD000,	3,	"; MSB = 0 - unknownn function, written with 2x");
	ExtLinA		(0XD000,	4,	"; MSB = 1 - writes to the ADC control register");
	ExtLinA		(0XD000,	5,	"; AN0 - MAPL");
	ExtLinA		(0XD000,	6,	"; AN1 - MAPR");
	ExtLinA		(0XD000,	7,	"; AN2 - Baro");
	ExtLinA		(0XD000,	8,	"; AN3 - IAT");
	ExtLinA		(0XD000,	9,	"; AN4 - CTS");
	ExtLinA		(0XD000,	10,	"; AN5 - VBatt");
	ExtLinA		(0XD000,	11,	"; AN6 - ");
	ExtLinA		(0XD000,	12,	"; AN7 - ");
	MakeByte	(0XD000);
	MakeName	(0XD000,	"PIA_Base");
	ExtLinA		(0XD001,	0,	";");
	ExtLinA		(0XD001,	1,	"; ADC Control Register");
	ExtLinA		(0XD001,	2,	"; bit 7 (0x80): ADC control");
	ExtLinA		(0XD001,	3,	"; bit 6 (0x40): Unknown/unimplemented");
	ExtLinA		(0XD001,	4,	"; bit 5 (0x20): Unknown/unimplemented ");
	ExtLinA		(0XD001,	5,	"; bit 4 (0x10): Unknown/unimplemented");
	ExtLinA		(0XD001,	6,	"; bit 3 (0x08): Unknown/unimplemented");
	ExtLinA		(0XD001,	7,	"; bit 2 (0x04): ADC Channel Select bit 2");
	ExtLinA		(0XD001,	8,	"; bit 1 (0x02): ADC Channel Select bit 1");
	ExtLinA		(0XD001,	9,	"; bit 0 (0x01): ADC Channel Select bit 0  ");
	MakeByte	(0XD001);
	MakeName	(0XD001,	"PIA_Ctrl");
	ExtLinA		(0XD002,	0,	";");
	ExtLinA		(0XD002,	1,	"; ADC Status Register");
	ExtLinA		(0XD002,	2,	"; bit 7 (0x80): Done");
	ExtLinA		(0XD002,	3,	"; bit 6 (0x40): Unknown/unimplemented");
	ExtLinA		(0XD002,	4,	"; bit 5 (0x20): Unknown/unimplemented ");
	ExtLinA		(0XD002,	5,	"; bit 4 (0x10): Unknown/unimplemented");
	ExtLinA		(0XD002,	6,	"; bit 3 (0x08): Unknown/unimplemented");
	ExtLinA		(0XD002,	7,	"; bit 2 (0x04): Unknown/unimplemented");
	ExtLinA		(0XD002,	8,	"; bit 1 (0x02): Unknown/unimplemented");
	ExtLinA		(0XD002,	9,	"; bit 0 (0x01): Unknown/unimplemented  ");
	MakeByte	(0XD002);
	MakeName	(0XD002,	"PIA_Status");
	ExtLinA		(0XD003,	0,	";");
	ExtLinA		(0XD003,	1,	"; ADC Result Register");
	ExtLinA		(0XD003,	2,	"; returns an 8-bit result");
	MakeByte	(0XD003);
	MakeName	(0XD003,	"PIA_Result");
	MakeWord	(0XE000);
	MakeName	(0XE000,	"X_E000");
	MakeWord	(0XE002);
	MakeWord	(0XE004);
	MakeWord	(0XE006);
	MakeName	(0XE008,	"X_E008");
	MakeWord	(0XE00C);
	MakeComm	(0XE00E,	" MAP related");
	MakeName	(0XE00E,	"X_E00E");
	MakeName	(0XE010,	"X_E010");
	MakeByte	(0XE011);
	MakeComm	(0XE012,	" baro multiplier = 54h = 84 ");
	MakeByte	(0XE012);
	MakeName	(0XE015,	"X_E015");
	MakeWord	(0XE019);
	MakeComm	(0XE01B,	" TPS ");
	MakeByte	(0XE01B);
	MakeByte	(0XE01C);
	MakeByte	(0XE01D);
	MakeComm	(0XE01E,	"TPS_Fault thresholds?");
	MakeByte	(0XE01E);
	MakeByte	(0XE01F);
	MakeComm	(0XE020,	"value for count 9D = 1*16ms");
	MakeByte	(0XE020);
	MakeWord	(0XE021);
	MakeWord	(0XE023);
	MakeWord	(0XE025);
	MakeWord	(0XE027);
	MakeByte	(0XE029);
	MakeByte	(0XE02A);
	MakeByte	(0XE02B);
	MakeByte	(0XE02C);
	MakeByte	(0XE02D);
	MakeName	(0XE02E,	"X_E02E");
	MakeComm	(0XE030,	"TPS fault thresholds?");
	MakeName	(0XE030,	"X_E030");
	MakeWord	(0XE032);
	MakeByte	(0XE034);
	MakeByte	(0XE035);
	MakeWord	(0XE036);
	MakeByte	(0XE039);
	MakeByte	(0XE03A);
	MakeByte	(0XE03B);
	MakeByte	(0XE03C);
	MakeRptCmt	(0XE040,	"sensor limits?");
	MakeName	(0XE040,	"X_E040");
	MakeByte	(0XE042);
	MakeName	(0XE042,	"MAPL_Default");
	MakeRptCmt	(0XE046,	"MAP default value");
	MakeByte	(0XE046);
	MakeName	(0XE046,	"MAPR_Default");
	MakeByte	(0XE058);
	MakeWord	(0XE060);
	MakeComm	(0XE064,	"limits for byte_90");
	MakeName	(0XE064,	"X_E064");
	ExtLinA		(0XE0C0,	0,	"Sensor Limits and default values");
	MakeName	(0XE0C0,	"MAPR_Limits");
	MakeComm	(0XE0C1,	"sensor limits?");
	MakeRptCmt	(0XE0C4,	"sensor limits start here? (+4)");
	MakeName	(0XE0C4,	"MAPL_Limits");
	MakeName	(0XE0C8,	"TPS_Limits");
	MakeName	(0XE0CC,	"BARO_Limits");
	MakeName	(0XE0D0,	"IAT_Limits");
	MakeName	(0XE0D4,	"CTS_Limits");
	MakeComm	(0XE0E0,	" TPS thresholds for table at E1C0 ");
	MakeByte	(0XE0E0);
	MakeByte	(0XE0E1);
	MakeByte	(0XE0E2);
	MakeByte	(0XE110);
	MakeArray	(0XE110,	0X8);
	MakeName	(0XE110,	"IAT_E110");
	MakeByte	(0XE120);
	MakeArray	(0XE120,	0X8);
	MakeName	(0XE120,	"Baro_E120");
	MakeByte	(0XE130);
	MakeArray	(0XE130,	0X10);
	MakeName	(0XE130,	"X_E130");
	MakeByte	(0XE150);
	MakeArray	(0XE150,	0XC);
	MakeName	(0XE150,	"VBatt_E150");
	MakeByte	(0XE160);
	MakeArray	(0XE160,	0X8);
	MakeName	(0XE160,	"CTS_E160");
	MakeByte	(0XE170);
	MakeArray	(0XE170,	0X10);
	MakeName	(0XE170,	"CTS_E170");
	MakeByte	(0XE180);
	MakeArray	(0XE180,	0X10);
	MakeName	(0XE180,	"CTS_E180");
	MakeByte	(0XE190);
	MakeArray	(0XE190,	0X10);
	MakeName	(0XE190,	"VBatt_E190");
	MakeComm	(0XE1A0,	" maybe dTPS");
	MakeRptCmt	(0XE1A0,	"appears to be dTPS");
	MakeName	(0XE1A0,	"X_E1A0");
	MakeComm	(0XE1B0,	" related to byte_86");
	MakeByte	(0XE1B0);
	MakeArray	(0XE1B0,	0X7);
	MakeName	(0XE1B0,	"X_E1B0");
	MakeComm	(0XE1C0,	"dTPS");
	MakeByte	(0XE1C0);
	MakeArray	(0XE1C0,	0X4);
	MakeName	(0XE1C0,	"dTPS_E1C0");
	ExtLinA		(0XE200,	0,	"X_E200: MAP v RPM");
	MakeByte	(0XE200);
	MakeArray	(0XE200,	0X100);
	MakeName	(0XE200,	"X_E200");
	ExtLinA		(0XE400,	0,	"X_E400: TPS v RPM");
	MakeByte	(0XE400);
	MakeArray	(0XE400,	0X100);
	MakeName	(0XE400,	"X_E400");
	ExtLinA		(0XE500,	0,	"X_E500: MAP v RPM");
	MakeByte	(0XE500);
	MakeArray	(0XE500,	0X100);
	MakeName	(0XE500,	"X_E500");
	ExtLinA		(0XE600,	0,	"X_600: TPS v RPM");
	MakeByte	(0XE600);
	MakeArray	(0XE600,	0X100);
	MakeName	(0XE600,	"X_E600");
	MakeName	(0XE77E,	"X_E77E");
	MakeWord	(0XE780);
	MakeArray	(0XE780,	0X8);
	MakeName	(0XE780,	"X_E780");
	MakeCode	(0XE7A0);
	MakeComm	(0XE7A3,	"what is at C000h?");
	MakeCode	(0XE7D1);
	MakeCode	(0XE7E7);
	MakeCode	(0XE800);
	MakeName	(0XE800,	"nIRQ_IntHandler");
	MakeComm	(0XE804,	"toggle P23 to clear nIRQ");
	MakeComm	(0XE811,	"not a valid address!");
	MakeComm	(0XE815,	"test IC2IF");
	MakeRptCmt	(0XE817,	"bra if no IC2 interrupt");
	MakeComm	(0XE81B,	"not cpx???");
	MakeComm	(0XE82D,	"bra if bit0 = 0");
	MakeComm	(0XE833,	"bra if bit7 = 0");
	MakeRptCmt	(0XE837,	"byte_84!!!");
	MakeComm	(0XE83A,	"clear count_C4");
	MakeCode	(0XE83D);
	MakeCode	(0XE880);
	MakeCode	(0XE88A);
	MakeComm	(0XE89E,	"inc byte_84");
	MakeCode	(0XE8AB);
	MakeCode	(0XE8B2);
	ExtLinA		(0XE900,	0,	"; IC_IntHandler:");
	ExtLinA		(0XE900,	1,	"; IC1 is the crank sensor input");
	ExtLinA		(0XE900,	2,	"; IC2 is ???");
	MakeCode	(0XE900);
	MakeName	(0XE900,	"IC_IntHandler");
	MakeComm	(0XE902,	"test IC1 IF");
	MakeComm	(0XE904,	" bra if IC1 interrupt");
	MakeRptCmt	(0XE904,	"bra if no IC1 interrupt");
	MakeComm	(0XE906,	"IC2 handler");
	MakeComm	(0XE909,	"IC1 Int");
	MakeRptCmt	(0XE909,	"clear interrupt flags");
	MakeCode	(0XE909);
	MakeComm	(0XE911,	"bra if no IC2 interrupt");
	ExtLinA		(0XE911,	0,	"check hex?");
	MakeComm	(0XE915,	"not CPX?");
	MakeComm	(0XE927,	"bra if bit0=0");
	MakeComm	(0XE931,	"byte_84 = 7");
	MakeComm	(0XE934,	"clear count_C4");
	MakeCode	(0XE937);
	MakeCode	(0XEA00);
	MakeName	(0XEA00,	"doTick_4ms");
	MakeComm	(0XEA03,	"always call but no code");
	MakeComm	(0XEA06,	"always call but no code");
	MakeRptCmt	(0XEA09,	"E7A0 = B6h");
	MakeRptCmt	(0XEA0C,	"There isn't anything at C000?");
	MakeComm	(0XEA0E,	"always bra");
	MakeComm	(0XEA10,	"never called");
	MakeComm	(0XEA16,	"RPM v TPS or MAP");
	MakeComm	(0XEA1C,	"TPS");
	MakeRptCmt	(0XEA1F,	"RPM v TPS");
	MakeComm	(0XEA25,	"CTS* BARO, VBatt");
	MakeComm	(0XEA2A,	"CTS* BARO, VBatt");
	MakeComm	(0XEA2D,	"RPM v TPS or MAP");
	MakeRptCmt	(0XEA30,	"RPM v TPS, CTS");
	MakeCode	(0XEA34);
	MakeCode	(0XEA41);
	MakeComm	(0XEA5D,	"dTPS");
	MakeRptCmt	(0XEA5D,	"TPS Value");
	MakeCode	(0XEA64);
	MakeComm	(0XEA8B,	" D = 86:87 ");
	MakeCode	(0XEA8B);
	MakeName	(0XEA8B,	"RPM_TPS_EA8B");
	MakeComm	(0XEA8D,	" =200h ");
	MakeComm	(0XEA90,	" bra if 86:87 >200h ");
	MakeComm	(0XEA94,	" TPS - F1h ");
	MakeComm	(0XEA97,	"bra if TPS>F1h) ");
	MakeComm	(0XEA99,	" else clear B ");
	MakeComm	(0XEA9C,	" TPS - byte_79 ");
	MakeComm	(0XEA9E,	" bra if TPS < byte_79 ");
	MakeComm	(0XEAA0,	" else point to a 4-byte table ");
	MakeComm	(0XEAA3,	" TPS - 3 ");
	MakeComm	(0XEAA6,	" bra if TPS<3 ");
	MakeComm	(0XEAA8,	" else X = E1C1 ");
	MakeComm	(0XEAA9,	" TPS - 5 ");
	MakeComm	(0XEAAC,	" bra if TPS<5");
	MakeComm	(0XEAAE,	" X = E1C2 ");
	MakeComm	(0XEAAF,	"TPS - Ah ");
	MakeComm	(0XEAB2,	" bra if TPS < A ");
	MakeComm	(0XEAB4,	" else X = E1C3 ");
	MakeComm	(0XEAB9,	"dTPS_5F");
	MakeCode	(0XEB00);
	MakeName	(0XEB00,	"MAP_EB00");
	MakeRptCmt	(0XEB0E,	"0 changed to nop !!");
	ExtLinA		(0XEB0E,	0,	"00, 00 changed to nop, nop to disassemble");
	MakeComm	(0XEB19,	" MAP lookup from 3d LUT at E200");
	MakeComm	(0XEB1B,	" otherwise a TPS look up");
	MakeName	(0XEB1B,	"TPS_EB1B");
	MakeComm	(0XEB20,	"wtf? - next line replaces B");
	MakeComm	(0XEB24,	"table scaling change");
	MakeComm	(0XEB28,	"B =32");
	MakeComm	(0XEB2C,	"B=8");
	MakeCode	(0XEB2C);
	MakeComm	(0XEB2D,	"A*8");
	MakeComm	(0XEB2E,	"minimum value");
	MakeCode	(0XEB39);
	MakeComm	(0XEB42,	"MAPL_T1 look up");
	MakeComm	(0XEB4C,	"MAPR_T1 lookup");
	MakeName	(0XEB4C,	"MAPR_LU");
	MakeComm	(0XEB58,	"use MAPR if MAPL fault*");
	MakeComm	(0XEB5A,	"get value from table look up");
	MakeComm	(0XEB5C,	"and save to byte_56");
	MakeComm	(0XEB5F,	" get MAPR_Raw ");
	MakeCode	(0XEB5F);
	MakeComm	(0XEB63,	" copy 56 to 58 ");
	MakeCode	(0XEB68);
	MakeName	(0XEB68,	"tableLU_3Db");
	ExtLinA		(0XEB74,	0,	"sub_EB74:");
	ExtLinA		(0XEB74,	1,	"RPM v TPS or MAP");
	ExtLinA		(0XEB74,	2,	"returns a value in byte_63");
	MakeCode	(0XEB74);
	MakeComm	(0XEB78,	"if bit2=0 get value from E500");
	MakeComm	(0XEB7A,	"else load default = 50h = 80 ");
	MakeCode	(0XEB7F);
	MakeComm	(0XEB8C,	"oim? - looks like a branch");
	MakeByte	(0XEB8C);
	MakeCode	(0XEB8F);
	MakeComm	(0XEB91,	"not reachable code");
	MakeCode	(0XEB91);
	MakeCode	(0XEB9E);
	MakeCode	(0XEBAC);
	MakeComm	(0XEBB2,	"TPS v RPM");
	MakeName	(0XEBB6,	"TPS_EBB6");
	MakeCode	(0XEBC7);
	MakeCode	(0XEBD3);
	MakeName	(0XEBD3,	"MAP_EBD3");
	MakeCode	(0XEBDB);
	MakeComm	(0XEBDD,	" bra if MAPR fault ");
	MakeComm	(0XEBDF,	" else get MAPL ");
	MakeComm	(0XEBE3,	" fetch MAPL, MAPR ");
	MakeCode	(0XEBE3);
	MakeComm	(0XEBE6,	" MAP average = (L+R)/2");
	MakeComm	(0XEC00,	" always call this");
	MakeCode	(0XEC00);
	MakeName	(0XEC00,	"Main_Loop");
	MakeRptCmt	(0XEC05,	"byte_8E - FRCH");
	MakeComm	(0XEC07,	"loop back if A<FRCH");
	MakeName	(0XEC09,	"calc_Tick_4ms");
	MakeRptCmt	(0XEC0D,	"tmr_4ms = FRC+4096");
	MakeComm	(0XEC38,	"isolate bit6");
	MakeCode	(0XEC3C);
	MakeComm	(0XEC3E,	"byte_84 = 16");
	MakeComm	(0XEC48,	"bra if status_A0 bit2 =1");
	MakeComm	(0XEC4C,	"clear byte_86");
	MakeComm	(0XEC5B,	"set bit6");
	MakeComm	(0XEC6E,	" turn on LED3 and LED2 ");
	MakeRptCmt	(0XEC72,	"clear byte_86");
	MakeRptCmt	(0XEC74,	"clear byte_AD");
	MakeRptCmt	(0XEC7B,	"toggle watchdog reset");
	MakeCode	(0XED00);
	MakeCode	(0XED01);
	ExtLinA		(0XED05,	0,	"injector right");
	MakeRptCmt	(0XED0E,	"test INJR");
	MakeComm	(0XED1C,	"clear INJR");
	ExtLinA		(0XED1E,	0,	"Ignition 34");
	MakeComm	(0XED2C,	"IGN34");
	MakeComm	(0XED2E,	"OCR1H - FRCH");
	MakeComm	(0XED30,	"has the time passed?");
	MakeComm	(0XED32,	"IGN34");
	MakeComm	(0XED34,	"OCR1H - 336us ");
	MakeComm	(0XED37,	"OCR1H-336us - FRCH");
	MakeComm	(0XED3F,	"test IGN34 pin");
	MakeComm	(0XED41,	"bra if IGN34 pin=1");
	MakeComm	(0XED43,	"clear ICF1");
	MakeComm	(0XED48,	"set IC1 En");
	MakeComm	(0XED51,	"IGN34 event in 20us");
	MakeCode	(0XED55);
	MakeComm	(0XED65,	"CAS_Count goes up as RPM goes down");
	MakeComm	(0XED67,	"bra if RPM increasing");
	MakeName	(0XED69,	"RPMdecreasing");
	MakeRptCmt	(0XED75,	"test INJL");
	MakeComm	(0XED77,	"bra if INJL pin = 0");
	MakeComm	(0XED83,	"clear INJL");
	MakeRptCmt	(0XED91,	"IGN12");
	MakeRptCmt	(0XED97,	"IGN12");
	MakeRptCmt	(0XEDA4,	"test IGN12 pin");
	MakeComm	(0XEDA6,	"bra if IGN12 pin = 1");
	MakeComm	(0XEDA8,	"clear IGN12 on next event");
	MakeComm	(0XEDB1,	"20us");
	MakeComm	(0XEDB6,	"IGN12 event in 20us");
	MakeCode	(0XEDBA);
	MakeComm	(0XEDCC,	"bra if RPM rising");
	MakeComm	(0XEDCE,	"else dCAS_Count - byte_B1");
	MakeWord	(0XEE00);
	MakeWord	(0XEE02);
	MakeWord	(0XEE04);
	MakeWord	(0XEE06);
	ExtLinA		(0XEE40,	0,	"loc_EE40:");
	ExtLinA		(0XEE40,	1,	" call with:");
	ExtLinA		(0XEE40,	2,	"   X = table base address + offfset");
	ExtLinA		(0XEE40,	3,	"   top of stack = return address");
	ExtLinA		(0XEE40,	4,	"   stack+1 = ADC value");
	ExtLinA		(0XEE40,	5,	"");
	MakeCode	(0XEE40);
	MakeCode	(0XEE54);
	MakeCode	(0XEE63);
	MakeCode	(0XEE7C);
	MakeComm	(0XEE93,	"=10h");
	MakeCode	(0XEEA6);
	MakeCode	(0XEEC8);
	MakeRptCmt	(0XEEDB,	"byte_A9 = 0");
	MakeCode	(0XEEF9);
	MakeComm	(0XEEFD,	"disable interrupts");
	MakeCode	(0XEEFD);
	MakeName	(0XEEFD,	"INIT");
	MakeComm	(0XEEFE,	"LEDs on, ?? ");
	ExtLinA		(0XEEFE,	0,	"initialise ports");
	MakeRptCmt	(0XEF01,	"PORT1 = FC\nPORT2 = 08 (WDogReset=1)");
	MakeComm	(0XEF06,	"P1DDR = FE\nP2DDR = 1E");
	MakeComm	(0XEF09,	"clear PORT2 all ");
	MakeRptCmt	(0XEF09,	"toggle WDogReset");
	ExtLinA		(0XEF0B,	0,	"initialise timers");
	MakeComm	(0XEF0E,	"set EICI, EOCI, IEDG, OLVL");
	MakeComm	(0XEF10,	"set EICI, EOCI, IEDG, OLVL");
	MakeComm	(0XEF12,	"=30us");
	MakeComm	(0XEF17,	"IGN34 event in 30us");
	MakeComm	(0XEF19,	"IGN12 event in 30us");
	MakeRptCmt	(0XEF19,	"init OCR2 pulse");
	MakeRptCmt	(0XEF1B,	"clear any timer1 interrupt flags");
	MakeRptCmt	(0XEF1D,	"clear any timer1 interrupts part2");
	MakeRptCmt	(0XEF1F,	"clear any timer2 interrupt flags");
	MakeRptCmt	(0XEF21,	"clear any timer2 interrupts part2");
	MakeRptCmt	(0XEF23,	"test the length of RAM??");
	ExtLinA		(0XEF23,	0,	"Initialise and test RAM from FF down");
	MakeRptCmt	(0XEF29,	"test for stuck at 1");
	MakeName	(0XEF29,	"testRAM");
	MakeRptCmt	(0XEF2F,	"if RAM failed loop forever");
	MakeComm	(0XEF31,	"test for stuck at 0");
	MakeRptCmt	(0XEF35,	"if RAM failed loop forever");
	ExtLinA		(0XEF3A,	0,	"initialise some more RAM variables");
	MakeComm	(0XEF47,	"count_91=2Fh");
	MakeComm	(0XEF49,	" byte_84=10h=16 ");
	ExtLinA		(0XEF4B,	0,	"initialise ADC");
	MakeRptCmt	(0XEF4E,	"start a conversion channel 0?");
	MakeRptCmt	(0XEF51,	"write to the result register?");
	ExtLinA		(0XEF54,	0,	"initialise some more RAM");
	ExtLinA		(0XEF58,	0,	"toggle the watchdog reset line");
	MakeRptCmt	(0XEF5C,	"toggle the watchdog");
	ExtLinA		(0XEF5E,	0,	"test for nIRQ code?");
	MakeRptCmt	(0XEF6C,	"loop forever");
	ExtLinA		(0XEF6E,	0,	"toggle watchdog");
	MakeComm	(0XEF72,	"toggle the watchdog");
	MakeRptCmt	(0XEF74,	"this needs checking!!");
	ExtLinA		(0XEF74,	0,	"test for code at 8000h - should always skip this");
	MakeRptCmt	(0XEF7B,	"there is no code here (test code?)");
	MakeComm	(0XEF8B,	"A:B = TPS:TPS");
	ExtLinA		(0XEF8B,	0,	"init TPS Buffer");
	MakeComm	(0XEF8E,	"TPS_T1:byte_77");
	MakeComm	(0XEF90,	"byte_78:byte_79");
	MakeComm	(0XEFA6,	"clear flags?");
	MakeComm	(0XEFB2,	"toggle P23 - IRQ?");
	MakeComm	(0XEFB6,	"toggle P23 - IRQ?");
	MakeComm	(0XEFBA,	"do something");
	MakeRptCmt	(0XEFBD,	"if not zero jump");
	MakeRptCmt	(0XEFBF,	"else byte_A9 = 7F");
	MakeComm	(0XEFC3,	"enable interrupts");
	MakeName	(0XEFC3,	"X_EFC3");
	MakeComm	(0XEFC4,	"jump to start of main loop");
	ExtLinA		(0XEFC7,	0,	"JMP_TBL1:");
	ExtLinA		(0XEFC7,	1,	" format:");
	ExtLinA		(0XEFC7,	2,	"   0,x = bit mask");
	ExtLinA		(0XEFC7,	3,	"   1,x = count");
	ExtLinA		(0XEFC7,	4,	"   2,x = function address");
	ExtLinA		(0XEFC7,	5,	"");
	MakeName	(0XEFC7,	"JMP_TBL1");
	MakeRptCmt	(0XEFC9,	"4.096ms tick");
	MakeWord	(0XEFC9);
	MakeComm	(0XEFCD,	"16.384ms tick");
	MakeWord	(0XEFCD);
	MakeComm	(0XEFD1,	"65.636ms tick");
	MakeWord	(0XEFD1);
	MakeRptCmt	(0XEFD5,	"262.14ms tick");
	MakeWord	(0XEFD5);
	MakeRptCmt	(0XEFD9,	"524.288ms tick");
	MakeWord	(0XEFD9);
	MakeComm	(0XEFDC,	"code");
	MakeCode	(0XEFDC);
	MakeName	(0XEFDC,	"JT1_done");
	ExtLinA		(0XEFDE,	0,	"");
	ExtLinA		(0XEFDE,	1,	"");
	MakeCode	(0XF000);
	MakeName	(0XF000,	"Reset");
	MakeComm	(0XF001,	"end of stack = FFh");
	MakeRptCmt	(0XF006,	"Port 4 are all outputs");
	MakeRptCmt	(0XF008,	"is there code present in 'otherchip'?");
	MakeRptCmt	(0XF00D,	"no looop forever!!");
	MakeRptCmt	(0XF00F,	"yes - execute the code");
	MakeCode	(0XF012);
	MakeName	(0XF012,	"doTick_8ms?");
	MakeName	(0XF015,	"sch_tick_4ms");
	MakeCode	(0XF041);
	MakeComm	(0XF045,	"bra if status_A0 bit6 = 1");
	MakeComm	(0XF049,	"byte_84=10h=16");
	MakeComm	(0XF04D,	"clear byte_86");
	MakeComm	(0XF05C,	"set bit6");
	MakeComm	(0XF06F,	"turn on LED3 and LED2");
	MakeComm	(0XF073,	"clear word_86");
	MakeComm	(0XF075,	"clear byte_AD");
	MakeComm	(0XF07C,	"toggle the watchdog");
	MakeComm	(0XF081,	"pointer to jump table at EFC7");
	MakeRptCmt	(0XF084,	"search for a match in the jump table");
	MakeRptCmt	(0XF085,	"EFC7 = 1");
	MakeRptCmt	(0XF087,	"bra if 0 (don't use jump table)");
	MakeComm	(0XF08F,	"get address of code");
	MakeName	(0XF08F,	"code_F08F");
	MakeRptCmt	(0XF091,	"and call that code");
	MakeComm	(0XF093,	"loop back");
	ExtLinA		(0XF096,	0,	"how do we get here? maybe orphan code");
	MakeCode	(0XF096);
	MakeRptCmt	(0XF09F,	"E7A0 = B6h");
	MakeCode	(0XF0C7);
	MakeComm	(0XF0F2,	"80h = MAPL");
	MakeCode	(0XF0F2);
	MakeName	(0XF0F2,	"Get_MAP");
	MakeName	(0XF0F4,	"get_MAPL");
	MakeRptCmt	(0XF0F8,	"return address = 95");
	MakeRptCmt	(0XF0FB,	"pointer to limits");
	MakeRptCmt	(0XF0FD,	"apply limits");
	MakeComm	(0XF10F,	"81h = MAPR");
	MakeName	(0XF10F,	"get_MAPR");
	MakeRptCmt	(0XF118,	"pointer to limits");
	MakeRptCmt	(0XF11A,	"apply limits");
	MakeRptCmt	(0XF11F,	"bra if MAPR = 0");
	MakeRptCmt	(0XF127,	"load default value");
	MakeCode	(0XF12D);
	MakeCode	(0XF13A);
	MakeCode	(0XF16E);
	ExtLinA		(0XF17C,	0,	"00, 00 changed to nop, nop to disassemble");
	MakeComm	(0XF187,	"bra if status_A0 bit0 = 0");
	MakeCode	(0XF19A);
	MakeCode	(0XF1A7);
	ExtLinA		(0XF1C0,	0,	"tableLU_3Da:");
	ExtLinA		(0XF1C0,	1,	"main 3D table look up, call with:");
	ExtLinA		(0XF1C0,	2,	"   X = base address");
	ExtLinA		(0XF1C0,	3,	"   D = a value");
	ExtLinA		(0XF1C0,	4,	"calls:");
	ExtLinA		(0XF1C0,	5,	"  table_LU_3D");
	MakeName	(0XF1C0,	"tableLU_3Da");
	MakeCode	(0XF1CC);
	MakeName	(0XF1CC,	"MAP_F1CC");
	MakeCode	(0XF1E8);
	MakeComm	(0XF1EC,	"83h = IAT");
	MakeCode	(0XF1EC);
	MakeName	(0XF1EC,	"doTick_262ms");
	MakeRptCmt	(0XF1F1,	"IAT_RAW");
	MakeRptCmt	(0XF1F4,	"pointer to limits");
	MakeRptCmt	(0XF1F6,	"test against limits");
	MakeRptCmt	(0XF203,	"84h = CTS");
	MakeRptCmt	(0XF208,	"CTS_Raw");
	MakeRptCmt	(0XF20B,	"pointer to limits");
	MakeComm	(0XF260,	"start ADC conversion");
	MakeCode	(0XF260);
	MakeName	(0XF260,	"readADC");
	MakeComm	(0XF266,	"test the status bit");
	MakeComm	(0XF268,	" loop\tback if\tbit6 =1");
	MakeRptCmt	(0XF268,	"loop back if not complete");
	MakeComm	(0XF26A,	"else get the result");
	MakeCode	(0XF26E);
	MakeName	(0XF26E,	"get_BARO");
	MakeComm	(0XF274,	"Baro = AN2");
	MakeRptCmt	(0XF27A,	"94 = Baro");
	MakeComm	(0XF299,	"B=54h =84");
	MakeComm	(0XF29C,	"Baro_70*84");
	MakeCode	(0XF2AC);
	MakeName	(0XF2AC,	"doTick_16ms");
	MakeComm	(0XF2C4,	"A4:A5");
	MakeComm	(0XF2CD,	"PORT1:PORT2");
	MakeRptCmt	(0XF2CD,	"get PORT1 pin values");
	MakeComm	(0XF2CF,	"LEDs OFF");
	MakeComm	(0XF2D1,	"LED_W on???");
	MakeComm	(0XF2D3,	"update PORT1:PORT2");
	MakeComm	(0XF2D7,	"test byte_A5");
	MakeRptCmt	(0XF2D7,	"test P27");
	MakeCode	(0XF2D7);
	MakeComm	(0XF2FD,	"count_8F << 4");
	MakeComm	(0XF301,	"LEDs off");
	MakeComm	(0XF303,	"add LED bits");
	MakeComm	(0XF306,	"LED_W off?");
	MakeComm	(0XF308,	"save PORT1:PORT2");
	MakeRptCmt	(0XF313,	"E065 = F0h");
	MakeCode	(0XF31B);
	MakeRptCmt	(0XF31C,	"E064 = 10h");
	MakeCode	(0XF327);
	MakeCode	(0XF32A);
	MakeComm	(0XF33C,	"LEDs off");
	MakeComm	(0XF342,	"VBAtt = AN5");
	MakeCode	(0XF342);
	MakeName	(0XF342,	"get_VBatt");
	MakeRptCmt	(0XF363,	"A= A-B");
	MakeName	(0XF374,	"code_F374");
	MakeComm	(0XF376,	"TPS - TPS_16ms");
	MakeComm	(0XF378,	"bra if TPS<TPS_16ms");
	MakeComm	(0XF37A,	"dTPS - 10h*");
	MakeComm	(0XF37D,	"bra if dTPS<10h");
	MakeComm	(0XF37F,	"else start count_6D");
	MakeComm	(0XF382,	"count_6D=10h");
	MakeComm	(0XF388,	"bit3 = dTPS>10h");
	MakeComm	(0XF38C,	"dec_count_6D");
	MakeCode	(0XF38C);
	MakeComm	(0XF38E,	"skip if 0");
	MakeComm	(0XF390,	"else decrement");
	MakeComm	(0XF391,	"and update");
	MakeComm	(0XF395,	"clear count_6D flag");
	MakeComm	(0XF399,	"clear bit3");
	MakeComm	(0XF39B,	"do a correction");
	MakeComm	(0XF39D,	"word_86 - 280h");
	MakeComm	(0XF3A0,	"bra if word_86> 280h");
	MakeComm	(0XF3A2,	"else test count_6D flag");
	MakeComm	(0XF3A6,	"bra if count_6D =0");
	MakeComm	(0XF3A8,	"else A=4");
	MakeComm	(0XF3AB,	"F3FB = ldd so LDAA would get thrown away");
	MakeRptCmt	(0XF3AB,	"3-cyle NOP, modified code or duff binary?");
	MakeComm	(0XF3AD,	"never comes here if F3AB is correct");
	MakeCode	(0XF3B0);
	MakeName	(0XF3B0,	"get_TPS");
	MakeCode	(0XF3C2);
	MakeName	(0XF3C2,	"do_TPS");
	MakeComm	(0XF3C4,	"78:79");
	MakeComm	(0XF3C8,	" D = TPS:TPS");
	MakeComm	(0XF3CE,	"TPS - TPS_16ms");
	MakeComm	(0XF3D0,	"bra if TPS>byte_79");
	MakeComm	(0XF3D2,	"else clear bit5");
	MakeComm	(0XF3D4,	"clear bit5");
	ExtLinA		(0XF3DA,	0,	"loc_F3DA:");
	ExtLinA		(0XF3DA,	1,	"Called with:");
	ExtLinA		(0XF3DA,	2,	"  A=Status_A0");
	ExtLinA		(0XF3DA,	3,	"  B=(TPS_T1-byte_79)");
	MakeCode	(0XF3DA);
	MakeComm	(0XF3E1,	"clear count if status_A0 bit5 = 0");
	MakeComm	(0XF3E5,	"bra if 16ms elapsed");
	MakeCode	(0XF3E8);
	MakeComm	(0XF3EB,	" A TPS delta?");
	MakeComm	(0XF3FB,	" also loc_EA8B");
	MakeComm	(0XF3FD,	"=200h");
	MakeComm	(0XF404,	"=F1");
	MakeRptCmt	(0XF404,	"=F1h");
	MakeRptCmt	(0XF40D,	"=1");
	MakeRptCmt	(0XF412,	"=1");
	MakeComm	(0XF41B,	"quit if status_A0 bit5 = 0");
	MakeComm	(0XF41F,	"set bit5");
	MakeCode	(0XF463);
	MakeCode	(0XF47A);
	MakeName	(0XF47A,	"doTick_65ms");
	MakeCode	(0XF485);
	MakeName	(0XF485,	"PIA_F485");
	MakeRptCmt	(0XF488,	"get status");
	MakeRptCmt	(0XF48B,	"test bit6");
	MakeRptCmt	(0XF48D,	"loop back if not done");
	MakeComm	(0XF48F,	"clear all but bit5");
	MakeCode	(0XF492);
	ExtLinA		(0XF498,	0,	"00,00 changed to nop,nop to disassemble");
	MakeComm	(0XF49D,	" table is all 0's ");
	MakeComm	(0XF4A3,	"always 0");
	MakeCode	(0XF4AF);
	MakeComm	(0XF4C3,	"bra if status_A0 bit4 = 1");
	MakeComm	(0XF4CB,	"set bit4");
	MakeCode	(0XF4CE);
	MakeComm	(0XF4E2,	"clear bit4");
	MakeCode	(0XF4E5);
	MakeComm	(0XF4E7,	"=200h");
	MakeComm	(0XF4F2,	"=3h");
	MakeComm	(0XF4F7,	"=0h");
	MakeComm	(0XF511,	"get MAPL");
	MakeCode	(0XF511);
	MakeComm	(0XF515,	"get MAPR");
	MakeRptCmt	(0XF519,	"get TPS");
	ExtLinA		(0XF519,	0,	"no MAP fault:");
	MakeComm	(0XF51B,	"bra if no fault");
	MakeComm	(0XF51D,	"set bit1 or bit0");
	MakeName	(0XF51D,	"TPS_fault");
	MakeCode	(0XF521);
	MakeRptCmt	(0XF523,	"bra if fault");
	MakeComm	(0XF525,	"clear flags");
	MakeComm	(0XF526,	"clear bit1 or bit0");
	MakeRptCmt	(0XF52A,	"Pulling the return address from the stack causes the \ncode to return to the routine before the one that called this code.");
	MakeCode	(0XF52A);
	MakeRptCmt	(0XF52F,	"set status_A0 bit2");
	ExtLinA		(0XF532,	0,	"TPS Fault:");
	MakeCode	(0XF532);
	MakeComm	(0XF534,	"TPS - 29h or 29h");
	MakeRptCmt	(0XF536,	"bra if TPS>29h");
	MakeRptCmt	(0XF538,	"else clear flags");
	MakeComm	(0XF539,	"clear bit1 or bit0");
	MakeComm	(0XF53D,	"TPS - 31h or 31h");
	MakeCode	(0XF53D);
	MakeRptCmt	(0XF53F,	"bra if TPS < 31h");
	MakeRptCmt	(0XF541,	"else set status_A0 bit0 or 1");
	MakeComm	(0XF545,	"clear bit2");
	MakeCode	(0XF548);
	MakeComm	(0XF54C,	"bra if status_A0 bit2 = 0");
	MakeCode	(0XF553);
	MakeComm	(0XF55F,	"OIM 80, 0");
	ExtLinA		(0XF55F,	0,	"this looks like code, 03 = OIM (extended instruction set)");
	MakeComm	(0XF560,	"byte_80 is dCAS_Count");
	MakeComm	(0XF561,	"OR with 0 won't do a lot!");
	MakeComm	(0XF562,	"bra $F569 ??");
	MakeComm	(0XF564,	"no entry point?");
	MakeCode	(0XF565);
	MakeComm	(0XF568,	"entry may be F569");
	MakeName	(0XF568,	"code_F568");
	MakeCode	(0XF571);
	MakeCode	(0XF57F);
	MakeComm	(0XF587,	"bra if status_A0 bit1=0");
	MakeName	(0XF589,	"TPS_F589");
	MakeCode	(0XF59A);
	MakeCode	(0XF5A6);
	MakeName	(0XF5A6,	"MAP_F5A6");
	MakeCode	(0XF5BA);
	ExtLinA		(0XF5C0,	0,	"00,00 changed to nop,nop to disassemble");
	MakeCode	(0XF5C2);
	MakeComm	(0XF5CF,	"not a valid address");
	MakeCode	(0XF5E6);
	MakeName	(0XF5E6,	"doTick_524ms");
	MakeComm	(0XF5E9,	"check for code at EE63");
	MakeRptCmt	(0XF5EB,	"exit if not present");
	MakeRptCmt	(0XF5ED,	"else call code");
	MakeCode	(0XF5F0);
	MakeCode	(0XF5F1);
	MakeName	(0XF5F1,	"limits_F5F1");
	MakeRptCmt	(0XF5F3,	"point X to table");
	MakeRptCmt	(0XF5F6,	"a flag?");
	MakeRptCmt	(0XF5F9,	"bra if flag? is zero");
	MakeRptCmt	(0XF5FB,	"else point to other table");
	MakeRptCmt	(0XF5FF,	"B = B * 4");
	MakeRptCmt	(0XF600,	"X = base address + (B*4)");
	MakeComm	(0XF601,	"A - limit 1");
	MakeRptCmt	(0XF603,	"bra if A<limit");
	MakeRptCmt	(0XF605,	"else A - Limit 2");
	MakeRptCmt	(0XF607,	"bra if A>limit");
	MakeRptCmt	(0XF609,	"else get default value?");
	MakeComm	(0XF60B,	" default value to AF? ");
	MakeRptCmt	(0XF610,	"16-bit table?");
	MakeComm	(0XF614,	"16-bit offset");
	MakeComm	(0XF627,	"return a value in B");
	MakeRptCmt	(0XF62A,	"return byte_AF in A");
	MakeCode	(0XF62A);
	MakeCode	(0XF62D);
	MakeCode	(0XF630);
	MakeCode	(0XF679);
	MakeCode	(0XF683);
	MakeCode	(0XF686);
	MakeCode	(0XF699);
	MakeCode	(0XF6AF);
	MakeCode	(0XF6BB);
	MakeCode	(0XF6CB);
	MakeComm	(0XF6DF,	"inc byte_84");
	MakeCode	(0XF6EB);
	MakeCode	(0XF6F2);
	MakeComm	(0XF6FC,	"get bank counter");
	MakeCode	(0XF6FC);
	MakeRptCmt	(0XF6FE,	"test bit1 (10h=4)");
	MakeComm	(0XF700,	"bra if 1");
	MakeRptCmt	(0XF700,	"if not 4 skip ?????");
	MakeRptCmt	(0XF702,	"else increment count");
	MakeRptCmt	(0XF703,	"and update");
	ExtLinA		(0XF706,	0,	"entry point?");
	MakeCode	(0XF706);
	MakeComm	(0XF70A,	"toggle P23 - nIRQ?");
	MakeComm	(0XF70E,	"toggle P23 - nIRQ?");
	MakeComm	(0XF71D,	"bra if !IC2 IF");
	MakeComm	(0XF73C,	"byte_84 = Fh");
	MakeCode	(0XF73F);
	MakeCode	(0XF745);
	MakeComm	(0XF747,	"test IC1 IF ");
	MakeComm	(0XF749,	"bra if !IC1 interrupt");
	MakeRptCmt	(0XF751,	"test IC2 IF");
	MakeComm	(0XF753,	" bra if !IC2 interrupt");
	MakeRptCmt	(0XF753,	"bra if ??");
	MakeName	(0XF757,	"IC2_F757?");
	MakeComm	(0XF773,	"byte_84 = 7");
	MakeCode	(0XF776);
	MakeCode	(0XF77C);
	MakeComm	(0XF786,	"bra if !IC2 IF");
	MakeCode	(0XF79A);
	MakeCode	(0XF7B2);
	ExtLinA		(0XF7B8,	0,	"");
	ExtLinA		(0XF7B8,	1,	"; count_4ms_B must be between 61.44ms and");
	ExtLinA		(0XF7B8,	2,	"; 81.92ms o0r count_4ms_B gets reset??");
	MakeRptCmt	(0XF7C2,	"test for RPM up or down");
	MakeComm	(0XF7D3,	"test for overflow");
	MakeComm	(0XF7D5,	"software extend counter");
	MakeRptCmt	(0XF7DF,	"shift left to test sign");
	MakeComm	(0XF7EB,	"count_A1 AND 3");
	MakeRptCmt	(0XF7F2,	"max count for count_C4 = 36");
	MakeCode	(0XF7FA);
	MakeCode	(0XF805);
	MakeComm	(0XF80A,	"bra if count_C4 bit 1=0");
	MakeCode	(0XF82A);
	MakeComm	(0XF835,	"4096 = 1831rpm");
	MakeComm	(0XF83F,	"byte_A2?");
	MakeCode	(0XF84C);
	MakeComm	(0XF853,	"(byte_84 - 0h");
	MakeComm	(0XF854,	"bra if byte_84 = 0");
	MakeCode	(0XF85C);
	MakeCode	(0XF865);
	MakeRptCmt	(0XF86E,	"7500h = 250rpm");
	MakeRptCmt	(0XF876,	"6D00h = 269rpm");
	MakeCode	(0XF876);
	MakeComm	(0XF893,	"byte_84=10h=16");
	MakeCode	(0XF89C);
	MakeCode	(0XF8C4);
	MakeRptCmt	(0XF8D1,	"=3h");
	MakeRptCmt	(0XF8E1,	"Bh");
	MakeRptCmt	(0XF8F1,	"B*2");
	MakeComm	(0XF8F2,	"JMP_TBL3");
	MakeRptCmt	(0XF8F8,	"jump to code pointed to from F8FA");
	MakeComm	(0XF8FA,	"JT3_0");
	ExtLinA		(0XF8FA,	0,	"JMP_TBL3:");
	ExtLinA		(0XF8FA,	1,	"16 address jump table");
	ExtLinA		(0XF8FA,	2,	"");
	MakeWord	(0XF8FA);
	MakeName	(0XF8FA,	"JMP_TBL3");
	MakeRptCmt	(0XF8FC,	"JT3_1");
	MakeWord	(0XF8FC);
	MakeRptCmt	(0XF8FE,	"JT3_2");
	MakeWord	(0XF8FE);
	MakeRptCmt	(0XF900,	"JT3_3");
	MakeWord	(0XF900);
	MakeRptCmt	(0XF902,	"should be F9EB????");
	MakeWord	(0XF902);
	MakeRptCmt	(0XF904,	"JT3_5");
	MakeWord	(0XF904);
	MakeRptCmt	(0XF906,	"JT3_5 (2)");
	MakeWord	(0XF906);
	MakeRptCmt	(0XF908,	"JT3_6");
	MakeWord	(0XF908);
	MakeRptCmt	(0XF90A,	"JT3_7");
	MakeWord	(0XF90A);
	MakeRptCmt	(0XF90C,	"JT3_1 (2)");
	MakeWord	(0XF90C);
	MakeRptCmt	(0XF90E,	"JT3_2 (2)");
	MakeWord	(0XF90E);
	MakeRptCmt	(0XF910,	"JT3_3 (2)");
	MakeWord	(0XF910);
	MakeRptCmt	(0XF912,	"JT3_4?");
	MakeWord	(0XF912);
	MakeRptCmt	(0XF914,	"JT3_5 (3)");
	MakeWord	(0XF914);
	MakeRptCmt	(0XF916,	"JT3_5 (4)");
	MakeWord	(0XF916);
	MakeRptCmt	(0XF918,	"JT3_6 (2)");
	MakeWord	(0XF918);
	MakeRptCmt	(0XF91A,	"rti");
	MakeWord	(0XF91A);
	MakeCode	(0XF91C);
	MakeName	(0XF91C,	"JT3_done");
	MakeCode	(0XF91D);
	MakeName	(0XF91D,	"JT3_0");
	MakeCode	(0XF942);
	MakeCode	(0XF974);
	MakeCode	(0XF990);
	MakeCode	(0XF995);
	MakeCode	(0XF99F);
	MakeComm	(0XF9AC,	"redirects to loc_FAEB");
	MakeCode	(0XF9BB);
	MakeCode	(0XF9C4);
	MakeCode	(0XF9C7);
	MakeName	(0XF9C7,	"JT3_1");
	MakeName	(0XF9DC,	"JT3_2");
	MakeComm	(0XF9E0,	"redirects to loc_FAEB");
	MakeCode	(0XF9E2);
	MakeName	(0XF9E2,	"JT3_3");
	MakeCode	(0XF9EB);
	MakeName	(0XF9EB,	"JT3_4?");
	MakeComm	(0XF9ED,	"600h = 4883rpm");
	MakeComm	(0XF9EF,	"bra if ????");
	MakeRptCmt	(0XF9F1,	"else toggle watchdog");
	MakeComm	(0XF9F5,	"toggle watchdog");
	MakeComm	(0XF9F9,	"cpx again??");
	MakeComm	(0XFA0B,	"redirects to loc_FAEB");
	MakeComm	(0XFA0D,	"48 = ?");
	MakeCode	(0XFA0D);
	MakeCode	(0XFA29);
	MakeComm	(0XFA2C,	"40=?");
	MakeCode	(0XFA53);
	MakeComm	(0XFA56,	"code?");
	MakeCode	(0XFA56);
	MakeName	(0XFA56,	"JT3_5");
	MakeCode	(0XFA5C);
	MakeName	(0XFA5C,	"JT3_6");
	MakeCode	(0XFA64);
	MakeName	(0XFA64,	"JT3_7");
	MakeCode	(0XFA71);
	MakeName	(0XFA71,	"Ign_FA71");
	MakeCode	(0XFA7D);
	MakeComm	(0XFA8A,	" set up a 5.12ms interrupt ");
	MakeCode	(0XFA96);
	MakeComm	(0XFA9E,	"IC1E =0, OLVL1 =0");
	MakeCode	(0XFAA2);
	MakeComm	(0XFAA4,	"test IGN34 pin");
	MakeComm	(0XFAA6,	"bra if IGN34 pin = 1");
	MakeComm	(0XFAAB,	"set IGN34 pin on next OC event");
	MakeComm	(0XFAB8,	"IGN34 event in 20us");
	MakeCode	(0XFABB);
	MakeName	(0XFABB,	"dCAS_FABB");
	MakeCode	(0XFAC9);
	MakeComm	(0XFACF,	"dCAS_AvH /2");
	MakeComm	(0XFAD7,	"dCAS_Av /2?");
	MakeComm	(0XFADE,	"new dCAS?");
	MakeName	(0XFAE0,	"clear_dCAS");
	MakeRptCmt	(0XFAE6,	"clear byte_AD");
	MakeCode	(0XFAE9);
	MakeCode	(0XFB06);
	MakeCode	(0XFB26);
	MakeName	(0XFB26,	"schedule_ign");
	MakeComm	(0XFB2A,	"bra if byte_50 bits[3:2} =0");
	MakeComm	(0XFB33,	"quit if byte_50 bits[1:0} =0");
	MakeCode	(0XFB39);
	MakeComm	(0XFB43,	"quit if status_A0 bit4 =1");
	MakeComm	(0XFB4E,	"test\tPORT1 for changes??");
	MakeComm	(0XFB50,	"turn off some pins?");
	MakeComm	(0XFB57,	"turn off some pins?");
	MakeCode	(0XFB84);
	MakeCode	(0XFBC8);
	MakeCode	(0XFBF0);
	MakeCode	(0XFBF8);
	MakeCode	(0XFC2A);
	MakeName	(0XFC2A,	"OC_IntHandler");
	MakeComm	(0XFC2F,	"Timer 1 OCIF and OCIE");
	MakeRptCmt	(0XFC33,	"Timer 2 OCIF and OCIE");
	MakeRptCmt	(0XFC35,	"test for Timer 2 OC interrupt");
	MakeRptCmt	(0XFC3D,	"test P11 (timer pin)");
	MakeName	(0XFC3D,	"OC1_IntHandler?");
	MakeComm	(0XFC41,	"bra if IGN12 pin = 1");
	MakeComm	(0XFC54,	"bra if IGN34 pin = 1");
	MakeCode	(0XFC85);
	MakeCode	(0XFC91);
	MakeName	(0XFC91,	"OC2_IntHandler?");
	MakeCode	(0XFC9A);
	MakeCode	(0XFCA7);
	MakeName	(0XFCA7,	"schedule_IGN34");
	MakeComm	(0XFCAB,	"test IGN34 pin");
	MakeComm	(0XFCAD,	"bra if pin = 1");
	MakeComm	(0XFCBB,	"set IGN34 on next OC event");
	MakeCode	(0XFCBF);
	MakeComm	(0XFCCB,	"clear IGN34 on next OC event");
	MakeComm	(0XFCCD,	"byte_48 or byte_4A");
	MakeComm	(0XFCD1,	"enable IGN34 interrupt");
	MakeComm	(0XFCDC,	"IGN34 event in 12us");
	MakeCode	(0XFCE0);
	MakeComm	(0XFCEA,	"IGN34 event in 65.5ms ???");
	MakeCode	(0XFCEF);
	MakeName	(0XFCEF,	"schedule_IGN12");
	MakeComm	(0XFCFF,	"byte_42");
	MakeCode	(0XFD07);
	MakeComm	(0XFD0F,	" byte_40 ???");
	MakeCode	(0XFD28);
	MakeCode	(0XFD37);
	MakeCode	(0XFD60);
	MakeCode	(0XFD9A);
	MakeComm	(0XFDAE,	"PORT1?");
	MakeCode	(0XFDB5);
	MakeComm	(0XFDCD,	"JMP_TBL2");
	MakeRptCmt	(0XFDD1,	"add offset to X");
	MakeComm	(0XFDD4,	"jump to sub-routine");
	MakeComm	(0XFDD6,	"IGN_FDDE");
	ExtLinA		(0XFDD6,	0,	"JMP_TBL2:");
	ExtLinA		(0XFDD6,	1,	"Add the offset to the address of the table entry");
	MakeName	(0XFDD6,	"JMP_TBL2");
	MakeComm	(0XFDD7,	"FDEC = JT2_1");
	MakeComm	(0XFDD8,	"FDEC = JT2_1");
	MakeComm	(0XFDD9,	"FDEC = JT2_1");
	MakeComm	(0XFDDA,	"FDEE = JT2_2");
	MakeComm	(0XFDDB,	"IGN_FE2A");
	MakeComm	(0XFDDC,	"FE05 = JT2_4");
	MakeComm	(0XFDDD,	"FE2A = JT2_3");
	MakeComm	(0XFDDE,	"FDD6+8");
	MakeCode	(0XFDDE);
	MakeName	(0XFDDE,	"IGN_FDDE");
	MakeComm	(0XFDE9,	"FDD6+14");
	MakeCode	(0XFDE9);
	MakeName	(0XFDE9,	"IGN34_FDE9");
	MakeComm	(0XFDEB,	"FDD6+15");
	MakeCode	(0XFDEC);
	MakeName	(0XFDEC,	"JT2_1");
	MakeCode	(0XFDEE);
	MakeName	(0XFDEE,	"JT2_2");
	MakeCode	(0XFE00);
	MakeCode	(0XFE05);
	MakeName	(0XFE05,	"JT2_4");
	MakeComm	(0XFE14,	"=TCSR1");
	MakeCode	(0XFE14);
	MakeComm	(0XFE17,	"=OC1/IGN34");
	MakeCode	(0XFE2A);
	MakeName	(0XFE2A,	"IGN_FE2A");
	MakeComm	(0XFE37,	"TCSR2");
	MakeComm	(0XFE3C,	"TCSR1");
	MakeCode	(0XFE3C);
	MakeComm	(0XFE3F,	"Bh = OCR1H");
	ExtLinA		(0XFE3F,	0,	"loc_FE3F:");
	ExtLinA		(0XFE3F,	1,	"come here with X = TCSR1 or TCSR2");
	MakeComm	(0XFE48,	"get TCSRn");
	MakeComm	(0XFE4C,	"clear IGNxx on next OCx event");
	MakeRptCmt	(0XFE4C,	"set Bit0");
	MakeComm	(0XFE56,	"IGNxx OC = byte_B7");
	MakeComm	(0XFE61,	"IGNxx OC = 20us");
	MakeComm	(0XFE7A,	" table_LU ");
	MakeCode	(0XFE7A);
	MakeComm	(0XFE88,	"is this not the return address???");
	MakeCode	(0XFE88);
	MakeComm	(0XFE99,	" 2D table LU ");
	MakeCode	(0XFE99);
	MakeComm	(0XFE9D,	" memory error - this should be 10h = a row/column ");
	MakeName	(0XFEAB,	"tableLU_2D");
	MakeCode	(0XFEBF);
	MakeName	(0XFEBF,	"tableLU_3D");
	MakeComm	(0XFEC2,	" A*16 = row/column");
	MakeCode	(0XFEE5);
	MakeCode	(0XFEE7);
	MakeComm	(0XFEEA,	"D = 89:90");
	MakeComm	(0XFEF3,	"byte_88 - 100h");
	MakeComm	(0XFEF5,	"bra if byte_88<100h");
	MakeComm	(0XFEF7,	"else load default !100h");
	MakeComm	(0XFEFD,	"local loop");
	MakeComm	(0XFF09,	"loop_FF09");
	MakeComm	(0XFF0B,	"exit when no upper bits = 1");
	MakeComm	(0XFF0D,	"D = D/2");
	MakeComm	(0XFF0E,	"decrement X");
	MakeCode	(0XFF11);
	MakeComm	(0XFF16,	"A*2");
	MakeComm	(0XFF17,	"(A*2) to B");
	MakeComm	(0XFF18,	"what is B?");
	ExtLinA		(0XFF28,	0,	"looks like code but can't get here");
	ExtLinA		(0XFF28,	1,	"      D/128, std byte_86, rts");
	ExtLinA		(0XFF28,	2,	"or data referenced from FF27 or FF2F");
	MakeCode	(0XFF32);
	MakeName	(0XFF32,	"mult_FF32");
	MakeComm	(0XFF43,	"bad entry point?");
	MakeName	(0XFF43,	"mult_FF43");
	MakeComm	(0XFF5B,	"jump to multiplication routine");
	MakeCode	(0XFF5D);
	MakeName	(0XFF5D,	"Mult_FF5D");
	MakeComm	(0XFF80,	"set carry");
	MakeCode	(0XFF86);
	MakeComm	(0XFF8B,	"always exit");
	ExtLinA		(0XFF8D,	0,	"never executed");
	MakeCode	(0XFFA6);
	MakeCode	(0XFFB2);
	MakeCode	(0XFFC6);
	MakeComm	(0XFFC9,	"test for code");
	MakeComm	(0XFFCB,	"always exit");
	ExtLinA		(0XFFCD,	0,	"never executed");
	MakeComm	(0XFFD0,	" stack = 4 ");
	MakeComm	(0XFFD4,	" stack = C008 ");
	ExtLinA		(0XFFD4,	0,	"loc_FFD4:");
	ExtLinA		(0XFFD4,	1,	"called from FFE7");
	MakeComm	(0XFFD5,	" D = (C008) ");
	MakeComm	(0XFFD8,	" stack = (C008) ");
	MakeComm	(0XFFD9,	" X = (C008) ");
	MakeComm	(0XFFDA,	" D = 0,(C008) ");
	MakeComm	(0XFFDC,	" X = C008 ");
	MakeComm	(0XFFDD,	" C00A = D ");
	MakeComm	(0XFFDF,	" stack = C008 ");
	MakeComm	(0XFFE1,	"  D = C008 ");
	MakeComm	(0XFFE2,	" X = loop count? ");
	MakeCode	(0XFFE7);
	MakeWord	(0XFFF0);
	MakeName	(0XFFF0,	"SIO");
	MakeWord	(0XFFF2);
	MakeName	(0XFFF2,	"TOI");
	MakeWord	(0XFFF4);
	MakeName	(0XFFF4,	"OC1");
	MakeWord	(0XFFF6);
	MakeName	(0XFFF6,	"IC1");
	MakeWord	(0XFFF8);
	MakeName	(0XFFF8,	"IRQ");
	MakeWord	(0XFFFA);
	MakeName	(0XFFFA,	"SWI");
	MakeWord	(0XFFFC);
	MakeName	(0XFFFC,	"NMI");
	MakeWord	(0XFFFE);
	MakeName	(0XFFFE,	"RESET");
}

static Functions_0(void) {

	MakeFunction    (0XE7A0,0XE7EC);
	SetFunctionFlags(0XE7A0,0x400);
	MakeFunction    (0XE880,0XE8BC);
	SetFunctionFlags(0XE880,0x400);
	MakeFunction    (0XEA00,0XEA34);
	SetFunctionFlags(0XEA00,0x400);
	MakeFunction    (0XEA34,0XEA8B);
	SetFunctionFlags(0XEA34,0x400);
	MakeFunction    (0XEB00,0XEB68);
	SetFunctionFlags(0XEB00,0x400);
	MakeNameEx(0XEB39, "MAP_EB39", SN_LOCAL);
	MakeFunction    (0XEB68,0XEB74);
	SetFunctionFlags(0XEB68,0x400);
	MakeFunction    (0XEC00,0XEC95);
	SetFunctionFlags(0XEC00,0x401);
	MakeFunction    (0XEEA6,0XEEFD);
	SetFunctionFlags(0XEEA6,0x400);
	MakeFunction    (0XEFDC,0XEFDE);
	SetFunctionFlags(0XEFDC,0x400);
	MakeFunction    (0XF0C7,0XF0F2);
	SetFunctionFlags(0XF0C7,0x400);
	MakeFunction    (0XF0F2,0XF12D);
	SetFunctionFlags(0XF0F2,0x400);
	MakeNameEx(0XF10D, "store_MAPL", SN_LOCAL);
	MakeNameEx(0XF12A, "store_MAPR", SN_LOCAL);
	MakeFunction    (0XF12D,0XF16E);
	SetFunctionFlags(0XF12D,0x400);
	MakeFunction    (0XF16E,0XF1C0);
	SetFunctionFlags(0XF16E,0x400);
	MakeFunction    (0XF1C0,0XF1CC);
	SetFunctionFlags(0XF1C0,0x400);
	MakeFunction    (0XF1CC,0XF1EC);
	SetFunctionFlags(0XF1CC,0x400);
	MakeFunction    (0XF1EC,0XF260);
	SetFunctionFlags(0XF1EC,0x400);
	MakeFunction    (0XF260,0XF26E);
	SetFunctionFlags(0XF260,0x400);
	MakeFunction    (0XF26E,0XF2AC);
	SetFunctionFlags(0XF26E,0x400);
	MakeFunction    (0XF2AC,0XF342);
	SetFunctionFlags(0XF2AC,0x400);
	MakeFunction    (0XF342,0XF3B0);
	SetFunctionFlags(0XF342,0x400);
	MakeFunction    (0XF3B0,0XF3C2);
	SetFunctionFlags(0XF3B0,0x400);
	MakeFunction    (0XF3C2,0XF425);
	SetFunctionFlags(0XF3C2,0x400);
	MakeNameEx(0XF3D6, "clr_Count_90", SN_LOCAL);
	MakeFunction    (0XF463,0XF47A);
	SetFunctionFlags(0XF463,0x400);
	MakeFunction    (0XF47A,0XF485);
	SetFunctionFlags(0XF47A,0x400);
	MakeFunction    (0XF485,0XF492);
	SetFunctionFlags(0XF485,0x400);
	MakeFunction    (0XF492,0XF4E5);
	SetFunctionFlags(0XF492,0x400);
	MakeFunction    (0XF4E5,0XF511);
	SetFunctionFlags(0XF4E5,0x400);
	MakeFunction    (0XF511,0XF548);
	SetFunctionFlags(0XF511,0x400);
	MakeNameEx(0XF521, "MAP_fault_F521", SN_LOCAL);
	MakeFunction    (0XF5E6,0XF5F1);
	SetFunctionFlags(0XF5E6,0x400);
	MakeFunction    (0XF5F1,0XF630);
	SetFunctionFlags(0XF5F1,0x400);
	MakeNameEx(0XF626, "setToZero", SN_LOCAL);
	MakeFunction    (0XF630,0XF660);
	SetFunctionFlags(0XF630,0x400);
	MakeFunction    (0XF660,0XF686);
	SetFunctionFlags(0XF660,0x400);
	MakeFunction    (0XF686,0XF6BB);
	SetFunctionFlags(0XF686,0x400);
	MakeFunction    (0XF6BB,0XF6FC);
	SetFunctionFlags(0XF6BB,0x400);
	MakeFunction    (0XF6FC,0XF706);
	SetFunctionFlags(0XF6FC,0x400);
	MakeFunction    (0XF91D,0XFA56);
	SetFunctionFlags(0XF91D,0x400);
	MakeFunction    (0XFA56,0XFA5C);
	SetFunctionFlags(0XFA56,0x400);
	MakeFunction    (0XFA5C,0XFA64);
	SetFunctionFlags(0XFA5C,0x400);
	MakeFunction    (0XFA64,0XFA71);
	SetFunctionFlags(0XFA64,0x400);
	MakeFunction    (0XFA71,0XFA96);
	SetFunctionFlags(0XFA71,0x400);
	MakeFunction    (0XFA96,0XFABB);
	SetFunctionFlags(0XFA96,0x400);
	MakeFunction    (0XFABB,0XFAC9);
	SetFunctionFlags(0XFABB,0x400);
	MakeFunction    (0XFAC9,0XFAE9);
	SetFunctionFlags(0XFAC9,0x400);
	MakeFunction    (0XFB06,0XFB26);
	SetFunctionFlags(0XFB06,0x400);
	MakeFunction    (0XFB26,0XFB39);
	SetFunctionFlags(0XFB26,0x400);
	MakeFunction    (0XFB39,0XFB84);
	SetFunctionFlags(0XFB39,0x400);
	MakeFunction    (0XFB84,0XFB95);
	SetFunctionFlags(0XFB84,0x400);
	MakeFunction    (0XFB95,0XFBB3);
	SetFunctionFlags(0XFB95,0x400);
	MakeFunction    (0XFBB3,0XFBBB);
	SetFunctionFlags(0XFBB3,0x400);
	MakeFunction    (0XFBBB,0XFBC8);
	SetFunctionFlags(0XFBBB,0x400);
	MakeFunction    (0XFBC8,0XFBF8);
	SetFunctionFlags(0XFBC8,0x400);
	MakeFunction    (0XFBF8,0XFC2A);
	SetFunctionFlags(0XFBF8,0x400);
	MakeFunction    (0XFC9A,0XFCA7);
	SetFunctionFlags(0XFC9A,0x400);
	MakeFunction    (0XFCA7,0XFCEF);
	SetFunctionFlags(0XFCA7,0x400);
	MakeFunction    (0XFCEF,0XFD37);
	SetFunctionFlags(0XFCEF,0x400);
	MakeFunction    (0XFD37,0XFD60);
	SetFunctionFlags(0XFD37,0x400);
	MakeFunction    (0XFD60,0XFD78);
	SetFunctionFlags(0XFD60,0x400);
	MakeFunction    (0XFD78,0XFDB5);
	SetFunctionFlags(0XFD78,0x400);
	MakeFunction    (0XFDB5,0XFDD6);
	SetFunctionFlags(0XFDB5,0x400);
	MakeFunction    (0XFDDE,0XFDE9);
	SetFunctionFlags(0XFDDE,0x400);
	MakeFunction    (0XFDE9,0XFDEC);
	SetFunctionFlags(0XFDE9,0x400);
	MakeFunction    (0XFDEC,0XFDED);
	SetFunctionFlags(0XFDEC,0x400);
	MakeFunction    (0XFDEE,0XFE68);
	SetFunctionFlags(0XFDEE,0x400);
	MakeNameEx(0XFE3C, "IGN_FE3C", SN_LOCAL);
	MakeFunction    (0XFE7A,0XFE88);
	SetFunctionFlags(0XFE7A,0x400);
	MakeFunction    (0XFE88,0XFE99);
	SetFunctionFlags(0XFE88,0x400);
	MakeFunction    (0XFE99,0XFEAB);
	SetFunctionFlags(0XFE99,0x400);
	MakeFunction    (0XFEAB,0XFEBF);
	SetFunctionFlags(0XFEAB,0x400);
	MakeFunction    (0XFEBF,0XFEE7);
	SetFunctionFlags(0XFEBF,0x400);
	MakeFunction    (0XFEE7,0XFF28);
	SetFunctionFlags(0XFEE7,0x400);
	MakeNameEx(0XFEFD, "loop_FEFD", SN_LOCAL);
	MakeNameEx(0XFF09, "loop_FF09", SN_LOCAL);
	MakeFunction    (0XFF5D,0XFF86);
	SetFunctionFlags(0XFF5D,0x400);
	MakeFunction    (0XFF86,0XFFC6);
	SetFunctionFlags(0XFF86,0x400);
	MakeFunction    (0XFFC6,0XFFF0);
	SetFunctionFlags(0XFFC6,0x400);
}

//------------------------------------------------------------------------
// Information about functions

static Functions(void) {

	Functions_0();
}

//------------------------------------------------------------------------
// Information about segment registers

static SegRegs(void) {
}

//------------------------------------------------------------------------
// Information about all patched bytes:

static Patches(void) {
}

//------------------------------------------------------------------------
// Call all byte feature functions:

static Bytes(void) {
	Bytes_0();
}

// End of file.
